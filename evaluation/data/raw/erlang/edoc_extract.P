-file("test/lib/edoc/src/edoc_extract.erl", 1).

-module(edoc_extract).

-export([source/3,
         source/4,
         source/5,
         header/3,
         header/4,
         header/5,
         file/4,
         text/4]).

-import(edoc_report, [report/3,warning/3]).

-file("test/lib/edoc/src/edoc.hrl", 1).

-file("/Users/parrt/Downloads/fenollp-erlang-grammar-c1db83d09307/test/lib/edoc/src/../include/edoc_doclet.hrl",
      1).

-record(context,{dir = "",env,opts = []}).

-record(doclet_gen,{sources = [],
                    app = [],
                    packages = [],
                    modules = [],
                    filemap}).

-record(doclet_toc,{paths,indir}).

-file("test/lib/edoc/src/edoc.hrl", 43).

-file([], 43).

-record(module,{name = [],
                parameters = none,
                functions = [],
                exports = [],
                attributes = [],
                records = [],
                encoding = latin1}).

-record(env,{module = [],
             package = [],
             root = "",
             file_suffix,
             package_summary,
             apps,
             modules,
             packages,
             app_default,
             macros = [],
             includes = []}).

-record(comment,{line = 0,text}).

-record(entry,{name,args = [],line = 0,export,data}).

-record(tag,{name,line = 0,origin = comment,data}).

-file("test/lib/edoc/src/edoc_extract.erl", 34).

source(File, Env, Opts) ->
    Forms = edoc:read_source(File, Opts),
    Comments = edoc:read_comments(File, Opts),
    source(Forms, Comments, File, Env, Opts).

source(Forms, Comments, File, Env, Opts) when is_list(Forms) ->
    Forms1 = erl_syntax:form_list(Forms),
    source(Forms1, Comments, File, Env, Opts);
source(Forms, Comments, File, Env, Opts) ->
    Tree = erl_recomment:quick_recomment_forms(Forms, Comments),
    TypeDocs = find_type_docs(Forms, Comments, Env, File),
    source1(Tree, File, Env, Opts, TypeDocs).

source(Forms, File, Env, Opts) when is_list(Forms) ->
    source(erl_syntax:form_list(Forms), File, Env, Opts);
source(Tree, File0, Env, Opts) ->
    TypeDocs = find_type_docs(Tree, [], Env, File0),
    source1(Tree, File0, Env, Opts, TypeDocs).

source1(Tree, File0, Env, Opts, TypeDocs) ->
    Forms = preprocess_forms(Tree),
    File = edoc_lib:filename(File0),
    Module = get_module_info(Tree, File),
    {Header,Footer,Entries} = collect(Forms, Module),
    Name = Module#module.name,
    Package = '',
    Env1 =
        Env#env{module = Name,
                package = Package,
                root = edoc_refs:relative_package_path('', Package)},
    Env2 = add_macro_defs(module_macros(Env1), Opts, Env1),
    Entries1 = get_tags([Header,Footer|Entries], Env2, File, TypeDocs),
    Entries2 = edoc_specs:add_data(Entries1, Opts, File, Module),
    edoc_tags:check_types(Entries2, Opts, File),
    Data = edoc_data:module(Module, Entries2, Env2, Opts),
    {Name,Data}.

header(File, Env, Opts) ->
    Forms = edoc:read_source(File),
    Comments = edoc:read_comments(File),
    header(Forms, Comments, File, Env, Opts).

header(Forms, Comments, File, Env, Opts) when is_list(Forms) ->
    Forms1 = erl_syntax:form_list(Forms),
    header(Forms1, Comments, File, Env, Opts);
header(Forms, Comments, File, Env, Opts) ->
    Tree = erl_recomment:quick_recomment_forms(Forms, Comments),
    header(Tree, File, Env, Opts).

header(Forms, File, Env, Opts) when is_list(Forms) ->
    header(erl_syntax:form_list(Forms), File, Env, Opts);
header(Tree, File0, Env, _Opts) ->
    Forms = preprocess_forms(Tree),
    File = edoc_lib:filename(File0),
    Module = #module{name = Env#env.module},
    {Header,Footer,Entries} = collect(Forms, Module),
    if
        Header#entry.data /= {[],[],[]} ->
            warning(File,
                    "documentation before module declaration is ignored"
                    " by @headerfile",
                    []);
        true ->
            ok
    end,
    if
        Entries /= [] ->
            warning(File,
                    "documentation before function definitions is ignor"
                    "ed by @headerfile",
                    []);
        true ->
            ok
    end,
    [Entry] = get_tags([Footer#entry{name = header}], Env, File),
    Entry#entry.data.

add_macro_defs(Defs0, Opts, Env) ->
    Defs = proplists:append_values(def, Opts),
    edoc_macros:check_defs(Defs),
    Env#env{macros = Defs ++ Defs0 ++ Env#env.macros}.

file(File, Context, Env, Opts) ->
    case file:read_file(File) of
        {ok,Bin} ->
            Enc =
                edoc_lib:read_encoding(File, [{in_comment_only,false}]),
            case catch unicode:characters_to_list(Bin, Enc) of
                String when is_list(String) ->
                    {ok,text(String, Context, Env, Opts, File)};
                _ ->
                    {error,invalid_unicode}
            end;
        {error,_} = Error ->
            Error
    end.

text(Text, Context, Env, Opts) ->
    text(Text, Context, Env, Opts, "").

text(Text, Context, Env, Opts, Where) ->
    Env1 = add_macro_defs(file_macros(Context, Env), Opts, Env),
    Cs = edoc_lib:lines(Text),
    Ts0 = edoc_tags:scan_lines(Cs, 1),
    Tags = sets:from_list(edoc_tags:tag_names()),
    Ts1 = edoc_tags:filter_tags(Ts0, Tags, Where),
    Single = sets:from_list(edoc_tags:tags(single)),
    Allow = sets:from_list(edoc_tags:tags(Context)),
    case edoc_tags:check_tags(Ts1, Allow, Single, Where) of
        true ->
            exit(error);
        false ->
            Ts2 = edoc_macros:expand_tags(Ts1, Env1, Where),
            How = dict:from_list(edoc_tags:tag_parsers()),
            edoc_tags:parse_tags(Ts2, How, Env1, Where)
    end.

get_module_info(Forms, File) ->
    L = case catch {ok,erl_syntax_lib:analyze_forms(Forms)} of
            {ok,L1} ->
                L1;
            syntax_error ->
                report(File, "syntax error in input.", []),
                exit(error);
            {'EXIT',R} ->
                exit(R);
            R ->
                throw(R)
        end,
    {Name,Vars} =
        case lists:keyfind(module, 1, L) of
            {module,N} when is_atom(N) ->
                {N,none};
            {module,{N,_} = Mod} when is_atom(N) ->
                Mod;
            _ ->
                report(File, "module name missing.", []),
                exit(error)
        end,
    Functions = ordsets:from_list(get_list_keyval(functions, L)),
    Exports = ordsets:from_list(get_list_keyval(exports, L)),
    Attributes = ordsets:from_list(get_list_keyval(attributes, L)),
    Records = get_list_keyval(records, L),
    Encoding = edoc_lib:read_encoding(File, []),
    #module{name = Name,
            parameters = Vars,
            functions = Functions,
            exports = ordsets:intersection(Exports, Functions),
            attributes = Attributes,
            records = Records,
            encoding = Encoding}.

get_list_keyval(Key, L) ->
    case lists:keyfind(Key, 1, L) of
        {Key,As} ->
            ordsets:from_list(As);
        _ ->
            []
    end.

preprocess_forms(Tree) ->
    preprocess_forms_1(erl_syntax:form_list_elements(erl_syntax:flatten_form_list(Tree))).

preprocess_forms_1([F|Fs]) ->
    case erl_syntax:get_precomments(F) of
        [] ->
            preprocess_forms_2(F, Fs);
        Cs ->
            Cs ++ preprocess_forms_2(F, Fs)
    end;
preprocess_forms_1([]) ->
    [].

preprocess_forms_2(F, Fs) ->
    case erl_syntax_lib:analyze_form(F) of
        comment ->
            [F|preprocess_forms_1(Fs)];
        {function,_} ->
            [F|preprocess_forms_1(Fs)];
        {rule,_} ->
            [F|preprocess_forms_1(Fs)];
        {attribute,{module,_}} ->
            [F|preprocess_forms_1(Fs)];
        text ->
            [F|preprocess_forms_1(Fs)];
        {attribute,{N,_}} ->
            case edoc_specs:is_tag(N) of
                true ->
                    [F|preprocess_forms_1(Fs)];
                false ->
                    preprocess_forms_1(Fs)
            end;
        _ ->
            preprocess_forms_1(Fs)
    end.

collect(Fs, Mod) ->
    collect(Fs, [], [], [], [], undefined, Mod).

collect([F|Fs], Cs, Ss, Ts, As, Header, Mod) ->
    case erl_syntax_lib:analyze_form(F) of
        comment ->
            collect(Fs, [F|Cs], Ss, Ts, As, Header, Mod);
        {function,Name} ->
            L = erl_syntax:get_pos(F),
            Export = ordsets:is_element(Name, Mod#module.exports),
            Args = parameters(erl_syntax:function_clauses(F)),
            collect(Fs,
                    [],
                    [],
                    [],
                    [#entry{name = Name,
                            args = Args,
                            line = L,
                            export = Export,
                            data = {comment_text(Cs),Ss,Ts}}|
                     As],
                    Header,
                    Mod);
        {rule,Name} ->
            L = erl_syntax:get_pos(F),
            Export = ordsets:is_element(Name, Mod#module.exports),
            Args = parameters(erl_syntax:rule_clauses(F)),
            collect(Fs,
                    [],
                    [],
                    [],
                    [#entry{name = Name,
                            args = Args,
                            line = L,
                            export = Export,
                            data = {comment_text(Cs),Ss,Ts}}|
                     As],
                    Header,
                    Mod);
        {attribute,{module,_}} when Header =:= undefined ->
            L = erl_syntax:get_pos(F),
            collect(Fs,
                    [],
                    [],
                    [],
                    As,
                    #entry{name = module,
                           line = L,
                           data = {comment_text(Cs),Ss,Ts}},
                    Mod);
        {attribute,{N,_}} ->
            case edoc_specs:tag(N) of
                spec ->
                    collect(Fs, Cs, [F|Ss], Ts, As, Header, Mod);
                type ->
                    collect(Fs, Cs, Ss, [F|Ts], As, Header, Mod);
                unknown ->
                    collect(Fs, [], [], [], As, Header, Mod)
            end;
        _ ->
            collect(Fs, [], [], [], As, Header, Mod)
    end;
collect([], Cs, Ss, Ts, As, Header, _Mod) ->
    Footer = #entry{name = footer,data = {comment_text(Cs),Ss,Ts}},
    As1 = lists:reverse(As),
    if
        Header =:= undefined ->
            {#entry{name = module,data = {[],[],[]}},Footer,As1};
        true ->
            {Header,Footer,As1}
    end.

comment_text(Cs) ->
    comment_text(Cs, []).

comment_text([C|Cs], Ss) ->
    L = erl_syntax:get_pos(C),
    comment_text(Cs,
                 [#comment{line = L,
                           text =
                               [ 
                                remove_percent_chars(S) ||
                                    S <- erl_syntax:comment_text(C)
                               ]}|
                  Ss]);
comment_text([], Ss) ->
    Ss.

remove_percent_chars([$%|Cs]) ->
    [$\s|remove_percent_chars(Cs)];
remove_percent_chars(Cs) ->
    Cs.

parameters(Clauses) ->
    select_names([ 
                  find_names(Ps) ||
                      Ps <- patterns(Clauses)
                 ]).

patterns(Cs) ->
    edoc_lib:transpose([ 
                        erl_syntax:clause_patterns(C) ||
                            C <- Cs
                       ]).

find_names(Ps) ->
    find_names(Ps, []).

find_names([P|Ps], Ns) ->
    case erl_syntax:type(P) of
        variable ->
            find_names(Ps, [tidy_name(erl_syntax:variable_name(P))|Ns]);
        match_expr ->
            P1 = erl_syntax:match_expr_pattern(P),
            P2 = erl_syntax:match_expr_body(P),
            find_names([P1,P2|Ps], Ns);
        list ->
            P1 = erl_syntax:list_tail(P),
            find_names([P1|Ps], Ns);
        record_expr ->
            A = erl_syntax:record_expr_type(P),
            N = list_to_atom(capitalize(erl_syntax:atom_name(A))),
            find_names(Ps, [N|Ns]);
        infix_expr ->
            P1 = erl_syntax:infix_expr_right(P),
            find_names([P1|Ps], Ns);
        _ ->
            find_names(Ps, Ns)
    end;
find_names([], Ns) ->
    lists:reverse(Ns).

select_names(Ls) ->
    select_names(Ls, [], sets:new()).

select_names([Ns|Ls], As, S) ->
    A = select_name(Ns, S),
    select_names(Ls, [A|As], sets:add_element(A, S));
select_names([], As, _) ->
    lists:reverse(As).

select_name([A|Ns], S) ->
    case sets:is_element(A, S) of
        true ->
            select_name(Ns, S);
        false ->
            A
    end;
select_name([], _S) ->
    '_'.

tidy_name(A) ->
    case atom_to_list(A) of
        [$_|Cs] ->
            list_to_atom(tidy_name_1(Cs));
        _ ->
            A
    end.

tidy_name_1([$_|Cs]) ->
    tidy_name_1(Cs);
tidy_name_1([C|_] = Cs) when C >= $A, C =< $Z ->
    Cs;
tidy_name_1([C|_] = Cs) when C >= $À, C =< $Þ, C =/= $× ->
    Cs;
tidy_name_1(Cs) ->
    [$_|Cs].

capitalize([C|Cs]) when C >= $a, C =< $z ->
    [C - 32|Cs];
capitalize(Cs) ->
    Cs.

-record(tags,{names,single,module,function,footer}).

get_tags(Es, Env, File) ->
    get_tags(Es, Env, File, dict:new()).

get_tags(Es, Env, File, TypeDocs) ->
    Tags =
        #tags{names = sets:from_list(edoc_tags:tag_names()),
              single = sets:from_list(edoc_tags:tags(single)),
              module = sets:from_list(edoc_tags:tags(module)),
              footer = sets:from_list(edoc_tags:tags(footer)),
              function = sets:from_list(edoc_tags:tags(function))},
    How = dict:from_list(edoc_tags:tag_parsers()),
    get_tags(Es, Tags, Env, How, File, TypeDocs).

get_tags([#entry{name = Name,data = {Cs,Specs,Types}} = E|Es],
         Tags,
         Env,
         How,
         File,
         TypeDocs) ->
    Where = {File,Name},
    Ts0 = scan_tags(Cs),
    {Ts1,Specs1} = select_spec(Ts0, Where, Specs),
    Ts2 = check_tags(Ts1, Tags, Where),
    Ts3 = edoc_macros:expand_tags(Ts2, Env, Where),
    Ts4 = edoc_tags:parse_tags(Ts3, How, Env, Where),
    Ts = selected_specs(Specs1, Ts4),
    ETypes =
        [ 
         edoc_specs:type(Type, TypeDocs) ||
             Type <- Types
        ],
    [E#entry{data = Ts ++ ETypes}|
     get_tags(Es, Tags, Env, How, File, TypeDocs)];
get_tags([], _, _, _, _, _) ->
    [].

scan_tags([#comment{line = L,text = Ss}|Es]) ->
    edoc_tags:scan_lines(Ss, L) ++ scan_tags(Es);
scan_tags([]) ->
    [].

check_tags(Ts0, Tags, Where) ->
    Ts = edoc_tags:filter_tags(Ts0, Tags#tags.names, Where),
    case check_tags_1(Ts, Tags, Where) of
        false ->
            Ts;
        true ->
            exit(error)
    end.

check_tags_1(Ts, Tags, {_,module} = Where) ->
    Allow = Tags#tags.module,
    Single = Tags#tags.single,
    edoc_tags:check_tags(Ts, Allow, Single, Where);
check_tags_1(Ts, Tags, {_,footer} = Where) ->
    Allow = Tags#tags.footer,
    Single = Tags#tags.single,
    edoc_tags:check_tags(Ts, Allow, Single, Where);
check_tags_1(Ts, Tags, Where) ->
    Allow = Tags#tags.function,
    Single = Tags#tags.single,
    edoc_tags:check_tags(Ts, Allow, Single, Where).

select_spec(Ts, {_,{_F,_A}}, Specs) ->
    case edoc_tags:filter_tags(Ts, sets:from_list([spec])) of
        [] ->
            {[ 
              edoc_specs:dummy_spec(S) ||
                  S <- Specs
             ]
             ++
             Ts,
             Specs};
        _ ->
            {Ts,[]}
    end;
select_spec(Ts, _Where, _Specs) ->
    {Ts,[]}.

selected_specs([], Ts) ->
    Ts;
selected_specs([F], [_|Ts]) ->
    [edoc_specs:spec(F, _Clause = 1)|Ts].

module_macros(Env) ->
    [{module,atom_to_list(Env#env.module)}]
    ++
    edoc_macros:std_macros(Env).

file_macros(_Context, Env) ->
    edoc_macros:std_macros(Env).

find_type_docs(Forms0, Comments, Env, File) ->
    Tree = erl_recomment:recomment_forms(Forms0, Comments),
    Forms = preprocess_forms(Tree),
    Env1 = add_macro_defs(edoc_macros:std_macros(Env), [], Env),
    F = fun(C, Line) ->
               find_fun(C, Line, Env1, File)
        end,
    edoc_specs:docs(Forms, F).

find_fun(C0, Line, Env, File) ->
    C1 = comment_text(C0),
    Text =
        lists:append([ 
                      C#comment.text ||
                          C <- C1
                     ]),
    Comm = #comment{line = Line,text = Text},
    [Tag|_] = scan_tags([Comm]),
    [Tag1] = edoc_macros:expand_tags([Tag], Env, File),
    Tag1.



