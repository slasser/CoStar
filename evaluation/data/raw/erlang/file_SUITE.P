-file("test/lib/kernel/test/file_SUITE.erl", 1).

-module(file_SUITE).

-export([all/0,
         suite/0,
         groups/0,
         init_per_suite/1,
         end_per_suite/1,
         init_per_group/2,
         end_per_group/2,
         init_per_testcase/2,
         end_per_testcase/2,
         read_write_file/1,
         names/1]).

-export([cur_dir_0/1,
         cur_dir_1/1,
         make_del_dir/1,
         list_dir/1,
         list_dir_error/1,
         untranslatable_names/1,
         untranslatable_names_error/1,
         pos1/1,
         pos2/1]).

-export([close/1,consult1/1,path_consult/1,delete/1]).

-export([eval1/1,
         path_eval/1,
         script1/1,
         path_script/1,
         open1/1,
         old_modes/1,
         new_modes/1,
         path_open/1,
         open_errors/1]).

-export([file_info_basic_file/1,
         file_info_basic_directory/1,
         file_info_bad/1,
         file_info_times/1,
         file_write_file_info/1]).

-export([rename/1,
         access/1,
         truncate/1,
         datasync/1,
         sync/1,
         read_write/1,
         pread_write/1,
         append/1,
         exclusive/1]).

-export([e_delete/1,e_rename/1,e_make_dir/1,e_del_dir/1]).

-export([otp_5814/1,otp_10852/1]).

-export([read_not_really_compressed/1,
         read_compressed_cooked/1,
         read_compressed_cooked_binary/1,
         read_cooked_tar_problem/1,
         write_compressed/1,
         compress_errors/1,
         catenated_gzips/1,
         compress_async_crash/1]).

-export([make_link/1,read_link_info_for_non_link/1,symlinks/1]).

-export([copy/1]).

-export([new_slave/2,old_slave/2,run_test/2]).

-export([delayed_write/1,read_ahead/1,segment_read/1,segment_write/1]).

-export([ipread/1]).

-export([pid2name/1]).

-export([interleaved_read_write/1]).

-export([altname/1]).

-export([large_file/1,large_write/1]).

-export([read_line_1/1,read_line_2/1,read_line_3/1,read_line_4/1]).

-export([advise/1]).

-export([allocate/1]).

-export([standard_io/1,mini_server/1]).

-export([old_io_protocol/1]).

-export([create_file_slow/2,create_file/2,create_bin/2]).

-export([verify_file/2,verify_bin/3]).

-export([bytes/2,iterate/3]).

-export([disc_free/1,memsize/0]).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/test_server-3.5.3/include/test_server.hrl",
      1).

-file("test/lib/kernel/test/file_SUITE.erl", 106).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/kernel-2.15.3/include/file.hrl",
      1).

-record(file_info,{size :: undefined | non_neg_integer(),
                   type :: undefined
                         | device
                         | directory
                         | other
                         | regular
                         | symlink,
                   access :: undefined
                           | read
                           | write
                           | read_write
                           | none,
                   atime :: undefined | file:date_time() | integer(),
                   mtime :: undefined | file:date_time() | integer(),
                   ctime :: undefined | file:date_time() | integer(),
                   mode :: undefined | integer(),
                   links :: undefined | non_neg_integer(),
                   major_device :: undefined | integer(),
                   minor_device :: undefined | integer(),
                   inode :: undefined | integer(),
                   uid :: undefined | integer(),
                   gid :: undefined | integer()}).

-record(file_descriptor,{module :: undefined | module(),
                         data :: undefined | term()}).

-file("test/lib/kernel/test/file_SUITE.erl", 107).

suite() ->
    [{ct_hooks,[ts_install_cth]}].

all() ->
    [altname,
     read_write_file,
     {group,dirs},
     {group,files},
     delete,
     rename,
     names,
     {group,errors},
     {group,compression},
     {group,links},
     copy,
     delayed_write,
     read_ahead,
     segment_read,
     segment_write,
     ipread,
     pid2name,
     interleaved_read_write,
     otp_5814,
     otp_10852,
     large_file,
     large_write,
     read_line_1,
     read_line_2,
     read_line_3,
     read_line_4,
     standard_io,
     old_io_protocol].

groups() ->
    [{dirs,
      [],
      [make_del_dir,
       cur_dir_0,
       cur_dir_1,
       list_dir,
       list_dir_error,
       untranslatable_names,
       untranslatable_names_error]},
     {files,
      [],
      [{group,open},
       {group,pos},
       {group,file_info},
       {group,consult},
       {group,eval},
       {group,script},
       truncate,
       sync,
       datasync,
       advise,
       allocate]},
     {open,
      [],
      [open1,
       old_modes,
       new_modes,
       path_open,
       close,
       access,
       read_write,
       pread_write,
       append,
       open_errors,
       exclusive]},
     {pos,[],[pos1,pos2]},
     {file_info,
      [],
      [file_info_basic_file,
       file_info_basic_directory,
       file_info_bad,
       file_info_times,
       file_write_file_info]},
     {consult,[],[consult1,path_consult]},
     {eval,[],[eval1,path_eval]},
     {script,[],[script1,path_script]},
     {errors,[],[e_delete,e_rename,e_make_dir,e_del_dir]},
     {compression,
      [],
      [read_compressed_cooked,
       read_compressed_cooked_binary,
       read_cooked_tar_problem,
       read_not_really_compressed,
       write_compressed,
       compress_errors,
       catenated_gzips,
       compress_async_crash]},
     {links,[],[make_link,read_link_info_for_non_link,symlinks]}].

init_per_group(_GroupName, Config) ->
    Config.

end_per_group(_GroupName, Config) ->
    Config.

init_per_suite(Config) when is_list(Config) ->
    SaslConfig =
        case application:start(sasl) of
            {error,{already_started,sasl}} ->
                [];
            ok ->
                [{sasl,started}]
        end,
    ok = application:start(os_mon),
    case os:type() of
        {win32,_} ->
            Priv = test_server:lookup_config(priv_dir, Config),
            HasAccessTime =
                case file:read_file_info(Priv) of
                    {ok,#file_info{atime = {_,{0,0,0}}}} ->
                        [no_access_time];
                    {ok,_} ->
                        []
                end,
            HasAccessTime ++ Config ++ SaslConfig;
        _ ->
            Config ++ SaslConfig
    end.

end_per_suite(Config) when is_list(Config) ->
    case os:type() of
        {win32,_} ->
            os:cmd("subst z: /d");
        _ ->
            ok
    end,
    application:stop(os_mon),
    case proplists:get_value(sasl, Config) of
        started ->
            application:stop(sasl);
        _Else ->
            ok
    end,
    Config.

init_per_testcase(_Func, Config) ->
    Config.

end_per_testcase(_Func, Config) ->
    Config.

expect(X, _, X) ->
    X;
expect(_, X, X) ->
    X.

expect(X, _, _, X) ->
    X;
expect(_, X, _, X) ->
    X;
expect(_, _, X, X) ->
    X.

expect(X, _, _, _, X) ->
    X;
expect(_, X, _, _, X) ->
    X;
expect(_, _, X, _, X) ->
    X;
expect(_, _, _, X, X) ->
    X.

time_dist({YY,MM,DD,H,M,S}, DT) ->
    time_dist({{YY,MM,DD},{H,M,S}}, DT);
time_dist(DT, {YY,MM,DD,H,M,S}) ->
    time_dist(DT, {{YY,MM,DD},{H,M,S}});
time_dist({_D1,_T1} = DT1, {_D2,_T2} = DT2) ->
    calendar:datetime_to_gregorian_seconds(DT2)
    -
    calendar:datetime_to_gregorian_seconds(DT1).

mini_server(Parent) ->
    receive
        die ->
            ok;
        {io_request,From,To,{put_chars,_Encoding,Data}} ->
            Parent ! {io_request,From,To,{put_chars,Data}},
            From ! {io_reply,To,ok},
            mini_server(Parent);
        {io_request,From,To,{get_chars,'',N}} ->
            Parent ! {io_request,From,To,{get_chars,'',N}},
            From ! {io_reply,To,{ok,lists:duplicate(N, $a)}},
            mini_server(Parent);
        {io_request,From,To,{get_line,''}} ->
            Parent ! {io_request,From,To,{get_line,''}},
            From ! {io_reply,To,{ok,"hej\n"}},
            mini_server(Parent)
    end.

standard_io(suite) ->
    [];
standard_io(doc) ->
    ["Test that standard i/o-servers work with file module"];
standard_io(Config) when is_list(Config) ->
    Pid = spawn(file_SUITE, mini_server, [self()]),
    register(mini_server, Pid),
    ok = file:write(mini_server, <<"hej\n">>),
    receive
        {io_request,_,_,{put_chars,<<"hej\n">>}} ->
            ok
    after
        1000 -> exit(noreply)
    end,
    {ok,"aaaaa"} = file:read(mini_server, 5),
    receive
        {io_request,_,_,{get_chars,'',5}} ->
            ok
    after
        1000 -> exit(noreply)
    end,
    {ok,"hej\n"} = file:read_line(mini_server),
    receive
        {io_request,_,_,{get_line,''}} ->
            ok
    after
        1000 -> exit(noreply)
    end,
    OldGL = group_leader(),
    group_leader(Pid, self()),
    ok = file:write(standard_io, <<"hej\n">>),
    group_leader(OldGL, self()),
    receive
        {io_request,_,_,{put_chars,<<"hej\n">>}} ->
            ok
    after
        1000 -> exit(noreply)
    end,
    group_leader(Pid, self()),
    {ok,"aaaaa"} = file:read(standard_io, 5),
    group_leader(OldGL, self()),
    receive
        {io_request,_,_,{get_chars,'',5}} ->
            ok
    after
        1000 -> exit(noreply)
    end,
    group_leader(Pid, self()),
    {ok,"hej\n"} = file:read_line(standard_io),
    group_leader(OldGL, self()),
    receive
        {io_request,_,_,{get_line,''}} ->
            ok
    after
        1000 -> exit(noreply)
    end,
    Pid ! die,
    receive after 1000 -> ok end.

old_io_protocol(suite) ->
    [];
old_io_protocol(doc) ->
    ["Test that the old file IO protocol =< R16B still works"];
old_io_protocol(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Name =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "old_io_protocol.fil"),
    MyData = "0123456789abcdefghijklmnopqrstuvxyz",
    ok = file:write_file(Name, MyData),
    {ok,Fd} = file:open(Name, write),
    Fd ! {file_request,self(),Fd,truncate},
    receive
        {file_reply,Fd,ok} ->
            ok
    end,
    ok = file:close(Fd),
    {ok,<<>>} = file:read_file(Name),
    test_server:timetrap_cancel(Dog),
    [] = flush(),
    ok.

read_write_file(suite) ->
    [];
read_write_file(doc) ->
    [];
read_write_file(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Name =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_read_write_file"),
    SomeTerm = {"This term",{will,be},[written,$t,$o],1,file,[]},
    ok = file:write_file(Name, term_to_binary(SomeTerm)),
    {ok,Bin1} = file:read_file(Name),
    SomeTerm = binary_to_term(Bin1),
    NullTerm = [],
    ok = file:write_file(Name, term_to_binary(NullTerm)),
    {ok,Bin2} = file:read_file(Name),
    NullTerm = binary_to_term(Bin2),
    BigNum = 123456789012345678901234567890,
    ComplTerm = {self(),make_ref(),BigNum,3.14159},
    ok = file:write_file(Name, term_to_binary(ComplTerm)),
    {ok,Bin3} = file:read_file(Name),
    ComplTerm = binary_to_term(Bin3),
    Name2 =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_nonexistent_file"),
    {error,enoent} = file:read_file(Name2),
    {error,enoent} = file:read_file(""),
    {error,enoent} = file:read_file(''),
    {error,enoent} = file:write_file("", term_to_binary(NullTerm)),
    {error,badarg} = file:write_file(Name, {1,2,3}),
    {error,badarg} = file:write_file(Name, self()),
    ok = file:write_file(Name, []),
    {ok,Bin4} = file:read_file(Name),
    0 = byte_size(Bin4),
    ok = file:write_file(Name, [Bin1,[],[[Bin2]]]),
    {ok,Bin5} = file:read_file(Name),
    {Bin1,Bin2} = split_binary(Bin5, byte_size(Bin1)),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

make_del_dir(suite) ->
    [];
make_del_dir(doc) ->
    [];
make_del_dir(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    NewDir =
        filename:join(RootDir, atom_to_list(file_SUITE) ++ "_mk-dir"),
    ok = file:make_dir(NewDir),
    {error,eexist} = file:make_dir(NewDir),
    ok = file:del_dir(NewDir),
    {error,enoent} = file:del_dir(NewDir),
    ok = file:make_dir(NewDir),
    {ok,CurrentDir} = file:get_cwd(),
    ok = file:set_cwd(NewDir),
    try
        NewDir2 =
            filename:join(RootDir,
                          atom_to_list(file_SUITE)
                          ++
                          "_mk-dir-noexist/foo"),
        {error,enoent} = file:make_dir(NewDir2),
        {error,enoent} = file:make_dir(""),
        {error,badarg} = file:make_dir({1,2,3}),
        {error,badarg} = file:make_dir([1,2,3,{}]),
        case file:del_dir('..') of
            {error,eexist} ->
                ok;
            {error,eacces} ->
                ok;
            {error,einval} ->
                ok
        end,
        {error,enoent} = file:del_dir(""),
        {error,badarg} = file:del_dir([3,2,1,{}]),
        [] = flush(),
        test_server:timetrap_cancel(Dog)
    after
        file:set_cwd(CurrentDir)
    end,
    ok.

cur_dir_0(suite) ->
    [];
cur_dir_0(doc) ->
    [];
cur_dir_0(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    {ok,BaseDir} = file:get_cwd(),
    Dir1 = BaseDir ++ "",
    ok = file:set_cwd(Dir1),
    RootDir = test_server:lookup_config(priv_dir, Config),
    NewDir =
        filename:join(RootDir, atom_to_list(file_SUITE) ++ "_curdir"),
    ok = file:make_dir(NewDir),
    io:format("cd to ~s", [NewDir]),
    ok = file:set_cwd(NewDir),
    UncommonName = "uncommon.fil",
    {ok,Fd} = file:open(UncommonName, read_write),
    ok = file:close(Fd),
    {ok,NewDirFiles} = file:list_dir("."),
    true = lists:member(UncommonName, NewDirFiles),
    expect({error,einval}, {error,eacces}, file:del_dir(NewDir)),
    file:delete(UncommonName),
    {ok,[]} = file:list_dir("."),
    ok = file:set_cwd(Dir1),
    io:format("cd back to ~s", [Dir1]),
    ok = file:del_dir(NewDir),
    {error,enoent} = file:set_cwd(NewDir),
    ok = file:set_cwd(Dir1),
    io:format("cd back to ~s", [Dir1]),
    {ok,OldDirFiles} = file:list_dir("."),
    false = lists:member(UncommonName, OldDirFiles),
    {error,badarg} = file:set_cwd({foo,bar}),
    {error,enoent} = file:set_cwd(""),
    {error,enoent} = file:set_cwd(".......a......"),
    {ok,BaseDir} = file:get_cwd(),
    {ok,BaseDir} = file:get_cwd(),
    false = lists:member($\\, BaseDir),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

cur_dir_1(suite) ->
    [];
cur_dir_1(doc) ->
    [];
cur_dir_1(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    case os:type() of
        {unix,_} ->
            {error,enotsup} = file:get_cwd("d:");
        {win32,_} ->
            win_cur_dir_1(Config)
    end,
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

win_cur_dir_1(_Config) ->
    {ok,BaseDir} = file:get_cwd(),
    [Drive,$:|_] = BaseDir,
    {ok,BaseDir} = file:get_cwd([Drive,$:]),
    io:format("BaseDir = ~s\n", [BaseDir]),
    ok.

list_dir_error(Config) ->
    Priv = test_server:lookup_config(priv_dir, Config),
    NonExisting = filename:join(Priv, "non-existing-dir"),
    {error,enoent} = file:list_dir(NonExisting),
    ok.

list_dir(Config) ->
    RootDir = test_server:lookup_config(priv_dir, Config),
    TestDir = filename:join(RootDir, "file_SUITE" ++ "_list_dir"),
    file:make_dir(TestDir),
    list_dir_1(TestDir, 42, []).

list_dir_1(TestDir, 0, Sorted) ->
    [ 
     ok = file:delete(filename:join(TestDir, F)) ||
         F <- Sorted
    ],
    ok = file:del_dir(TestDir);
list_dir_1(TestDir, Cnt, Sorted0) ->
    Base = "file" ++ integer_to_list(Cnt),
    Name = filename:join(TestDir, Base),
    ok = file:write_file(Name, Base),
    Sorted = lists:merge([Base], Sorted0),
    {ok,DirList0} = file:list_dir(TestDir),
    {ok,DirList1} = file:list_dir_all(TestDir),
    Sorted = lists:sort(DirList0),
    Sorted = lists:sort(DirList1),
    list_dir_1(TestDir, Cnt - 1, Sorted).

untranslatable_names(Config) ->
    case no_untranslatable_names() of
        true ->
            {skip,"Not a problem on this OS"};
        false ->
            untranslatable_names_1(Config)
    end.

untranslatable_names_1(Config) ->
    {ok,OldCwd} = file:get_cwd(),
    PrivDir = test_server:lookup_config(priv_dir, Config),
    Dir = filename:join(PrivDir, "untranslatable_names"),
    ok = file:make_dir(Dir),
    Node = start_node(untranslatable_names, "+fnu"),
    try
        ok = file:set_cwd(Dir),
        [ 
         ok = file:write_file(F, F) ||
             {_,F} <- untranslatable_names()
        ],
        ExpectedListDir0 =
            [ 
             unicode:characters_to_list(N, utf8) ||
                 {utf8,N} <- untranslatable_names()
            ],
        ExpectedListDir = lists:sort(ExpectedListDir0),
        io:format("ExpectedListDir: ~p\n", [ExpectedListDir]),
        ExpectedListDir = call_and_sort(Node, file, list_dir, [Dir]),
        ExpectedListDirAll0 =
            [ 
             case Enc of
                 utf8 ->
                     unicode:characters_to_list(N, utf8);
                 latin1 ->
                     N
             end ||
                 {Enc,N} <- untranslatable_names()
            ],
        ExpectedListDirAll = lists:sort(ExpectedListDirAll0),
        io:format("ExpectedListDirAll: ~p\n", [ExpectedListDirAll]),
        ExpectedListDirAll =
            call_and_sort(Node, file, list_dir_all, [Dir])
    after
        catch test_server:stop_node(Node),
        file:set_cwd(OldCwd),
        [ 
         file:delete(F) ||
             {_,F} <- untranslatable_names()
        ],
        file:del_dir(Dir)
    end,
    ok.

untranslatable_names_error(Config) ->
    case no_untranslatable_names() of
        true ->
            {skip,"Not a problem on this OS"};
        false ->
            untranslatable_names_error_1(Config)
    end.

untranslatable_names_error_1(Config) ->
    {ok,OldCwd} = file:get_cwd(),
    PrivDir = test_server:lookup_config(priv_dir, Config),
    Dir = filename:join(PrivDir, "untranslatable_names_error"),
    ok = file:make_dir(Dir),
    Node = start_node(untranslatable_names, "+fnue"),
    try
        ok = file:set_cwd(Dir),
        [ 
         ok = file:write_file(F, F) ||
             {_,F} <- untranslatable_names()
        ],
        ExpectedListDir0 =
            [ 
             unicode:characters_to_list(N, utf8) ||
                 {utf8,N} <- untranslatable_names()
            ],
        ExpectedListDir = lists:sort(ExpectedListDir0),
        io:format("ExpectedListDir: ~p\n", [ExpectedListDir]),
        {error,{no_translation,BadFile}} =
            rpc:call(Node, file, list_dir, [Dir]),
        true = lists:keymember(BadFile, 2, untranslatable_names())
    after
        catch test_server:stop_node(Node),
        file:set_cwd(OldCwd),
        [ 
         file:delete(F) ||
             {_,F} <- untranslatable_names()
        ],
        file:del_dir(Dir)
    end,
    ok.

untranslatable_names() ->
    [{utf8,<<"abc">>},
     {utf8,<<"def">>},
     {utf8,<<"Lagerl",195,182,"f">>},
     {utf8,<<195,150,"stra Emterwik">>},
     {latin1,<<"M",229,"rbacka">>},
     {latin1,<<"V",228,"rmland">>}].

call_and_sort(Node, M, F, A) ->
    {ok,Res} = rpc:call(Node, M, F, A),
    lists:sort(Res).

no_untranslatable_names() ->
    case os:type() of
        {unix,darwin} ->
            true;
        {win32,_} ->
            true;
        _ ->
            false
    end.

start_node(Name, Args) ->
    [_,Host] = string:tokens(atom_to_list(node()), "@"),
    ct:log("Trying to start ~w@~s~n", [Name,Host]),
    case test_server:start_node(Name, peer, [{args,Args}]) of
        {error,Reason} ->
            test_server:fail(Reason);
        {ok,Node} ->
            ct:log("Node ~p started~n", [Node]),
            Node
    end.

open1(suite) ->
    [];
open1(doc) ->
    [];
open1(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    NewDir =
        filename:join(RootDir, atom_to_list(file_SUITE) ++ "_files"),
    ok = file:make_dir(NewDir),
    Name = filename:join(NewDir, "foo1.fil"),
    {ok,Fd1} = file:open(Name, read_write),
    {ok,Fd2} = file:open(Name, read),
    Str = "{a,tuple}.\n",
    io:format(Fd1, Str, []),
    {ok,0} = file:position(Fd1, bof),
    Str = io:get_line(Fd1, ''),
    Str = io:get_line(Fd2, ''),
    ok = file:close(Fd2),
    {ok,0} = file:position(Fd1, bof),
    ok = file:truncate(Fd1),
    eof = io:get_line(Fd1, ''),
    ok = file:close(Fd1),
    {ok,Fd3} = file:open(Name, read),
    eof = io:get_line(Fd3, ''),
    ok = file:close(Fd3),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

old_modes(suite) ->
    [];
old_modes(doc) ->
    [];
old_modes(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    NewDir =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_old_open_modes"),
    ok = file:make_dir(NewDir),
    Name1 = filename:join(NewDir, "foo1.fil"),
    Marker = "hello, world",
    {ok,Fd1} = file:open(Name1, write),
    ok = io:write(Fd1, Marker),
    ok = io:put_chars(Fd1, ".\n"),
    ok = file:close(Fd1),
    {ok,Fd2} = file:open(Name1, read),
    {ok,Marker} = io:read(Fd2, prompt),
    ok = file:close(Fd2),
    {ok,Fd3} = file:open(Name1, read_write),
    {ok,Marker} = io:read(Fd3, prompt),
    ok = io:write(Fd3, Marker),
    ok = file:close(Fd3),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

new_modes(suite) ->
    [];
new_modes(doc) ->
    [];
new_modes(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    NewDir =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_new_open_modes"),
    ok = file:make_dir(NewDir),
    Name1 = filename:join(NewDir, "foo1.fil"),
    Marker = "hello, world",
    {ok,Fd1} = file:open(Name1, [write]),
    ok = io:write(Fd1, Marker),
    ok = io:put_chars(Fd1, ".\n"),
    ok = file:close(Fd1),
    {ok,Fd2} = file:open(Name1, [read]),
    {ok,Marker} = io:read(Fd2, prompt),
    ok = file:close(Fd2),
    {ok,Fd3} = file:open(Name1, [read,write]),
    {ok,Marker} = io:read(Fd3, prompt),
    ok = io:write(Fd3, Marker),
    ok = file:close(Fd3),
    {ok,Fd4} = file:open(Name1, []),
    {ok,Marker} = io:read(Fd4, prompt),
    ok = file:close(Fd4),
    {ok,Fd5} = file:open(Name1, [read,binary]),
    {ok,Marker} = io:read(Fd5, prompt),
    ok = file:close(Fd5),
    {ok,Fd6} = file:open(Name1, [read,raw]),
    {ok,[$[]} = file:read(Fd6, 1),
    ok = file:close(Fd6),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

path_open(suite) ->
    [];
path_open(doc) ->
    [];
path_open(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    NewDir =
        filename:join(RootDir, atom_to_list(file_SUITE) ++ "_path_open"),
    ok = file:make_dir(NewDir),
    FileName = "path_open.fil",
    Name = filename:join(RootDir, FileName),
    {ok,Fd1,_FullName1} =
        file:path_open([RootDir,"nosuch1",NewDir], FileName, write),
    io:format(Fd1, "ABCDEFGH", []),
    ok = file:close(Fd1),
    {ok,Fd2,_FullName2} =
        file:path_open(["nosuch1",NewDir,RootDir], FileName, read),
    {ok,2} = file:position(Fd2, 2),
    "C" = io:get_chars(Fd2, '', 1),
    ok = file:close(Fd2),
    {error,enoent} = file:path_open(["nosuch1",NewDir], FileName, read),
    {ok,Fd3,_FullPath3} = file:path_open(["nosuch1",NewDir], Name, read),
    {ok,2} = file:position(Fd3, 2),
    "C" = io:get_chars(Fd3, '', 1),
    ok = file:close(Fd3),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

close(suite) ->
    [];
close(doc) ->
    [];
close(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Name =
        filename:join(RootDir, atom_to_list(file_SUITE) ++ "_close.fil"),
    {ok,Fd1} = file:open(Name, read_write),
    {'EXIT',_Msg} = (catch ok = file:close({ok,Fd1})),
    ok = file:close(Fd1),
    Val = file:close(Fd1),
    io:format("Second close gave: ~p", [Val]),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

access(suite) ->
    [];
access(doc) ->
    [];
access(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Name =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_access.fil"),
    Str = "ABCDEFGH",
    {ok,Fd1} = file:open(Name, write),
    io:format(Fd1, Str, []),
    ok = file:close(Fd1),
    {ok,Fd2} = file:open(Name, read),
    case catch io:format(Fd2, "XXXX", []) of
        ok ->
            test_server:fail({format,write});
        _ ->
            ok
    end,
    ok = file:close(Fd2),
    {ok,Fd3} = file:open(Name, read),
    Str = io:get_line(Fd3, ''),
    ok = file:close(Fd3),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

read_write(suite) ->
    [];
read_write(doc) ->
    [];
read_write(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    NewDir =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_read_write"),
    ok = file:make_dir(NewDir),
    Marker = "hello, world",
    MarkerB = list_to_binary(Marker),
    Name1 = filename:join(NewDir, "plain.fil"),
    {ok,Fd1} = file:open(Name1, [read,write]),
    read_write_test(Fd1, Marker, []),
    Name2 = filename:join(NewDir, "raw.fil"),
    {ok,Fd2} = file:open(Name2, [read,write,raw]),
    read_write_test(Fd2, Marker, []),
    Name3 = filename:join(NewDir, "plain-b.fil"),
    {ok,Fd3} = file:open(Name3, [read,write,binary]),
    read_write_test(Fd3, MarkerB, <<>>),
    Name4 = filename:join(NewDir, "raw-b.fil"),
    {ok,Fd4} = file:open(Name4, [read,write,raw,binary]),
    read_write_test(Fd4, MarkerB, <<>>),
    test_server:timetrap_cancel(Dog),
    ok.

read_write_test(File, Marker, Empty) ->
    ok = file:write(File, Marker),
    {ok,0} = file:position(File, 0),
    {ok,Empty} = file:read(File, 0),
    {ok,Marker} = file:read(File, 100),
    eof = file:read(File, 100),
    {ok,Empty} = file:read(File, 0),
    ok = file:close(File),
    [] = flush(),
    ok.

pread_write(suite) ->
    [];
pread_write(doc) ->
    [];
pread_write(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    NewDir =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_pread_write"),
    ok = file:make_dir(NewDir),
    List = "hello, world",
    Bin = list_to_binary(List),
    Name1 = filename:join(NewDir, "plain.fil"),
    {ok,Fd1} = file:open(Name1, [read,write]),
    pread_write_test(Fd1, List),
    Name2 = filename:join(NewDir, "raw.fil"),
    {ok,Fd2} = file:open(Name2, [read,write,raw]),
    pread_write_test(Fd2, List),
    Name3 = filename:join(NewDir, "plain-binary.fil"),
    {ok,Fd3} = file:open(Name3, [binary,read,write]),
    pread_write_test(Fd3, Bin),
    Name4 = filename:join(NewDir, "raw-binary.fil"),
    {ok,Fd4} = file:open(Name4, [binary,read,write,raw]),
    pread_write_test(Fd4, Bin),
    test_server:timetrap_cancel(Dog),
    ok.

pread_write_test(File, Data) ->
    io:format("~p:pread_write_test(~p,~p)~n", [file_SUITE,File,Data]),
    Size =
        if
            is_binary(Data) ->
                byte_size(Data);
            is_list(Data) ->
                length(Data)
        end,
    I = Size + 17,
    ok = file:pwrite(File, 0, Data),
    Res = file:pread(File, 0, I),
    {ok,Data} = Res,
    eof = file:pread(File, I, 1),
    ok = file:pwrite(File, [{0,Data},{I,Data}]),
    {ok,[Data,eof,Data]} =
        file:pread(File, [{0,Size},{2 * I,1},{I,Size}]),
    Plist = lists:seq(21 * I, 0, - I),
    Pwrite =
        lists:map(fun(P) ->
                         {P,Data}
                  end,
                  Plist),
    Pread =
        [{22 * I,Size}|
         lists:map(fun(P) ->
                          {P,Size}
                   end,
                   Plist)],
    Presult =
        [eof|
         lists:map(fun(_) ->
                          Data
                   end,
                   Plist)],
    ok = file:pwrite(File, Pwrite),
    {ok,Presult} = file:pread(File, Pread),
    ok = file:close(File),
    [] = flush(),
    ok.

append(doc) ->
    "Test appending to a file.";
append(suite) ->
    [];
append(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    NewDir =
        filename:join(RootDir, atom_to_list(file_SUITE) ++ "_append"),
    ok = file:make_dir(NewDir),
    First = "First line\n",
    Second = "Seond lines comes here\n",
    Third = "And here is the third line\n",
    Name1 = filename:join(NewDir, "a_file.txt"),
    {ok,Fd1} = file:open(Name1, [write]),
    ok = io:format(Fd1, First, []),
    ok = io:format(Fd1, Second, []),
    ok = file:close(Fd1),
    {ok,Fd2} = file:open(Name1, [append]),
    ok = io:format(Fd2, Third, []),
    ok = file:close(Fd2),
    Expected = list_to_binary([First,Second,Third]),
    {ok,Expected} = file:read_file(Name1),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

open_errors(suite) ->
    [];
open_errors(doc) ->
    [];
open_errors(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    DataDir =
        filename:dirname(filename:join(test_server:lookup_config(data_dir,
                                                                 Config),
                                       "x")),
    DataDirSlash = DataDir ++ "/",
    {error,E1} = file:open(DataDir, [read]),
    {error,E2} = file:open(DataDirSlash, [read]),
    {error,E3} = file:open(DataDir, [write]),
    {error,E4} = file:open(DataDirSlash, [write]),
    {eisdir,eisdir,eisdir,eisdir} = {E1,E2,E3,E4},
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

exclusive(suite) ->
    [];
exclusive(doc) ->
    "Test exclusive access to a file.";
exclusive(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    NewDir =
        filename:join(RootDir, atom_to_list(file_SUITE) ++ "_exclusive"),
    ok = file:make_dir(NewDir),
    Name = filename:join(NewDir, "ex_file.txt"),
    {ok,Fd} = file:open(Name, [write,exclusive]),
    {error,eexist} = file:open(Name, [write,exclusive]),
    ok = file:close(Fd),
    test_server:timetrap_cancel(Dog),
    ok.

pos1(suite) ->
    [];
pos1(doc) ->
    [];
pos1(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Name =
        filename:join(RootDir, atom_to_list(file_SUITE) ++ "_pos1.fil"),
    {ok,Fd1} = file:open(Name, write),
    io:format(Fd1, "ABCDEFGH", []),
    ok = file:close(Fd1),
    {ok,Fd2} = file:open(Name, read),
    io:format("Relative positions"),
    "A" = io:get_chars(Fd2, '', 1),
    {ok,2} = file:position(Fd2, {cur,1}),
    "C" = io:get_chars(Fd2, '', 1),
    {ok,0} = file:position(Fd2, {cur,- 3}),
    "A" = io:get_chars(Fd2, '', 1),
    {ok,0} = file:position(Fd2, {cur,- 1}),
    {error,einval} = file:position(Fd2, {cur,- 1}),
    {ok,0} = file:position(Fd2, 0),
    {ok,2} = file:position(Fd2, {cur,2}),
    "C" = io:get_chars(Fd2, '', 1),
    {ok,13} = file:position(Fd2, {cur,10}),
    eof = io:get_chars(Fd2, '', 1),
    io:format("Fixed positions"),
    {ok,8} = file:position(Fd2, 8),
    eof = io:get_chars(Fd2, '', 1),
    {ok,8} = file:position(Fd2, cur),
    eof = io:get_chars(Fd2, '', 1),
    {ok,7} = file:position(Fd2, 7),
    "H" = io:get_chars(Fd2, '', 1),
    {ok,0} = file:position(Fd2, 0),
    "A" = io:get_chars(Fd2, '', 1),
    {ok,3} = file:position(Fd2, 3),
    "D" = io:get_chars(Fd2, '', 1),
    {ok,12} = file:position(Fd2, 12),
    eof = io:get_chars(Fd2, '', 1),
    {ok,3} = file:position(Fd2, 3),
    "D" = io:get_chars(Fd2, '', 1),
    {ok,3} = file:position(Fd2, {bof,3}),
    "D" = io:get_chars(Fd2, '', 1),
    io:format("EOF positions"),
    {ok,8} = file:position(Fd2, {eof,0}),
    eof = io:get_chars(Fd2, '', 1),
    {ok,7} = file:position(Fd2, {eof,- 1}),
    "H" = io:get_chars(Fd2, '', 1),
    {ok,0} = file:position(Fd2, {eof,- 8}),
    "A" = io:get_chars(Fd2, '', 1),
    {error,einval} = file:position(Fd2, {eof,- 9}),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

pos2(suite) ->
    [];
pos2(doc) ->
    [];
pos2(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Name =
        filename:join(RootDir, atom_to_list(file_SUITE) ++ "_pos2.fil"),
    {ok,Fd1} = file:open(Name, write),
    io:format(Fd1, "ABCDEFGH", []),
    ok = file:close(Fd1),
    {ok,Fd2} = file:open(Name, read),
    {error,einval} = file:position(Fd2, - 1),
    {ok,0} = file:position(Fd2, 0),
    {ok,3} = file:position(Fd2, {bof,3}),
    "D" = io:get_chars(Fd2, '', 1),
    [] = flush(),
    io:format("DONE"),
    test_server:timetrap_cancel(Dog),
    ok.

file_info_basic_file(suite) ->
    [];
file_info_basic_file(doc) ->
    [];
file_info_basic_file(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Name =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_basic_test.fil"),
    {ok,Fd1} = file:open(Name, write),
    io:put_chars(Fd1, "foo bar"),
    ok = file:close(Fd1),
    {ok,
     #file_info{size = Size,
                type = Type,
                access = Access,
                atime = AccessTime,
                mtime = ModifyTime}} =
        file:read_file_info(Name),
    io:format("Access ~p, Modify ~p", [AccessTime,ModifyTime]),
    Size = 7,
    Type = regular,
    read_write = Access,
    true =
        abs(time_dist(filter_atime(AccessTime, Config),
                      filter_atime(ModifyTime, Config)))
        <
        2,
    all_integers(tuple_to_list(AccessTime) ++ tuple_to_list(ModifyTime)),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

file_info_basic_directory(suite) ->
    [];
file_info_basic_directory(doc) ->
    [];
file_info_basic_directory(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir =
        filename:join([test_server:lookup_config(priv_dir, Config)]),
    test_directory(RootDir, read_write),
    case os:type() of
        {win32,_} ->
            test_directory("/", read_write),
            test_directory("c:/", read_write),
            test_directory("c:\\", read_write);
        {unix,_} ->
            test_directory("/", read)
    end,
    test_server:timetrap_cancel(Dog).

test_directory(Name, ExpectedAccess) ->
    {ok,
     #file_info{size = Size,
                type = Type,
                access = Access,
                atime = AccessTime,
                mtime = ModifyTime}} =
        file:read_file_info(Name),
    io:format("Testing directory ~s", [Name]),
    io:format("Directory size is ~p", [Size]),
    io:format("Access ~p", [Access]),
    io:format("Access time ~p; Modify time~p", [AccessTime,ModifyTime]),
    Type = directory,
    Access = ExpectedAccess,
    all_integers(tuple_to_list(AccessTime) ++ tuple_to_list(ModifyTime)),
    [] = flush(),
    ok.

all_integers([{A,B,C}|T]) ->
    all_integers([A,B,C|T]);
all_integers([Int|Rest]) when is_integer(Int) ->
    all_integers(Rest);
all_integers([]) ->
    ok.

file_info_bad(suite) ->
    [];
file_info_bad(doc) ->
    [];
file_info_bad(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir =
        filename:join([test_server:lookup_config(priv_dir, Config)]),
    {error,enoent} =
        file:read_file_info(filename:join(RootDir,
                                          atom_to_list(file_SUITE)
                                          ++
                                          "_nonexistent")),
    {error,enoent} = file:read_file_info(""),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

file_info_times(suite) ->
    [];
file_info_times(doc) ->
    [];
file_info_times(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(60)),
    test_server:m_out_of_n(1,
                           2,
                           fun() ->
                                  file_info_int(Config)
                           end),
    test_server:timetrap_cancel(Dog),
    ok.

file_info_int(Config) ->
    RootDir =
        filename:join([test_server:lookup_config(priv_dir, Config)]),
    test_server:format("RootDir = ~p", [RootDir]),
    Name =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_file_info.fil"),
    {ok,Fd1} = file:open(Name, write),
    io:put_chars(Fd1, "foo"),
    {ok,#file_info{type = regular,atime = AccTime1,mtime = ModTime1}} =
        file:read_file_info(Name),
    Now = erlang:localtime(),
    io:format("Now ~p", [Now]),
    io:format("Open file Acc ~p Mod ~p", [AccTime1,ModTime1]),
    true =
        abs(time_dist(filter_atime(Now, Config),
                      filter_atime(AccTime1, Config)))
        <
        8,
    true = abs(time_dist(Now, ModTime1)) < 8,
    test_server:sleep(test_server:seconds(2.2)),
    ok = file:close(Fd1),
    {ok,
     #file_info{size = Size,
                type = regular,
                access = Access,
                atime = AccTime2,
                mtime = ModTime2}} =
        file:read_file_info(Name),
    io:format("Closed file Acc ~p Mod ~p", [AccTime2,ModTime2]),
    true = time_dist(ModTime1, ModTime2) >= 0,
    Size = 3,
    Access = read_write,
    {ok,
     #file_info{size = DSize,
                type = directory,
                access = DAccess,
                atime = AccTime3,
                mtime = ModTime3}} =
        file:read_file_info(RootDir),
    io:format("Dir Acc ~p; Mod ~p; Now ~p", [AccTime3,ModTime3,Now]),
    true = abs(time_dist(Now, ModTime3)) < 5,
    DAccess = read_write,
    io:format("Dir size is ~p", [DSize]),
    [] = flush(),
    ok.

filter_atime(Atime, Config) ->
    case lists:member(no_access_time, Config) of
        true ->
            case Atime of
                {Date,_} ->
                    {Date,{0,0,0}};
                {Y,M,D,_,_,_} ->
                    {Y,M,D,0,0,0}
            end;
        false ->
            Atime
    end.

file_write_file_info(suite) ->
    [];
file_write_file_info(doc) ->
    [];
file_write_file_info(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    RootDir = get_good_directory(Config),
    test_server:format("RootDir = ~p", [RootDir]),
    Name1 =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_write_file_info_ro"),
    ok = file:write_file(Name1, "hello"),
    Time = {{1997,1,2},{12,35,42}},
    Info = #file_info{mode = 256,atime = Time,mtime = Time,ctime = Time},
    ok = file:write_file_info(Name1, Info),
    {ok,ActualInfo} = file:read_file_info(Name1),
    #file_info{mode = _Mode,
               atime = ActAtime,
               mtime = Time,
               ctime = ActCtime} =
        ActualInfo,
    FilteredAtime = filter_atime(Time, Config),
    FilteredAtime = filter_atime(ActAtime, Config),
    case os:type() of
        {win32,_} ->
            ActCtime = Time;
        _ ->
            ok
    end,
    {error,eacces} = file:write_file(Name1, "hello again"),
    file:write_file_info(Name1, #file_info{mode = 384}),
    ok = file:write_file(Name1, "hello again"),
    file:write_file_info(Name1, #file_info{mode = 256}),
    {error,eacces} = file:write_file(Name1, "hello again"),
    NewTime = {{1997,2,15},{13,18,20}},
    NewInfo =
        #file_info{atime = NewTime,mtime = NewTime,ctime = NewTime},
    ok = file:write_file_info(Name1, NewInfo),
    {ok,ActualInfo2} = file:read_file_info(Name1),
    #file_info{atime = NewActAtime,mtime = NewTime,ctime = NewActCtime} =
        ActualInfo2,
    NewFilteredAtime = filter_atime(NewTime, Config),
    NewFilteredAtime = filter_atime(NewActAtime, Config),
    case os:type() of
        {win32,_} ->
            NewActCtime = NewTime;
        _ ->
            ok
    end,
    {error,eacces} = file:write_file(Name1, "hello again"),
    file:write_file_info(Name1, #file_info{mode = 384}),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

get_good_directory(Config) ->
    test_server:lookup_config(priv_dir, Config).

consult1(suite) ->
    [];
consult1(doc) ->
    [];
consult1(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Name =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_consult.fil"),
    {ok,Fd1} = file:open(Name, write),
    io:format(Fd1,
              "{this,[is,1.0],'journey'}.\n\"into\". (sound). ",
              []),
    ok = file:close(Fd1),
    {ok,[{this,[is,1.0],journey},"into",sound]} = file:consult(Name),
    {ok,Fd2} = file:open(Name, write),
    io:format(Fd2, "{this,[is,1.0],'journey'}.\n \"into. (sound). ", []),
    ok = file:close(Fd2),
    {error,{_,_,_} = Msg} = file:consult(Name),
    io:format("Errmsg: ~p", [Msg]),
    {error,enoent} = file:consult(Name ++ ".nonexistent"),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

path_consult(suite) ->
    [];
path_consult(doc) ->
    [];
path_consult(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    FileName = atom_to_list(file_SUITE) ++ "_path_consult.fil",
    Name = filename:join(RootDir, FileName),
    {ok,Fd1} = file:open(Name, write),
    io:format(Fd1, "{this,is,a,journey,into,sound}.\n", []),
    ok = file:close(Fd1),
    {ok,[{this,is,a,journey,into,sound}],Dir} =
        file:path_consult([filename:join(RootDir, "dir1"),
                           filename:join(RootDir, ".."),
                           filename:join(RootDir, "dir2"),
                           RootDir],
                          FileName),
    true = lists:prefix(RootDir, Dir),
    {ok,_,_} = file:path_consult(["nosuch1","nosuch2"], Name),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

eval1(suite) ->
    [];
eval1(doc) ->
    [];
eval1(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Name =
        filename:join(RootDir, atom_to_list(file_SUITE) ++ "_eval.fil"),
    {ok,Fd1} = file:open(Name, write),
    io:format(Fd1, "put(evaluated_ok,\ntrue). ", []),
    ok = file:close(Fd1),
    ok = file:eval(Name),
    true = get(evaluated_ok),
    {ok,Fd2} = file:open(Name, write),
    io:format(Fd2, "put(evaluated_ok,\nR). ", []),
    ok = file:close(Fd2),
    ok =
        file:eval(Name,
                  erl_eval:add_binding('R',
                                       true,
                                       erl_eval:new_bindings())),
    true = get(evaluated_ok),
    {ok,Fd3} = file:open(Name, write),
    io:format(Fd3, "puGARBLED-GARBLED\ntrue). ", []),
    ok = file:close(Fd3),
    {error,{_,_,_} = Msg} = file:eval(Name),
    io:format("Errmsg1: ~p", [Msg]),
    {error,enoent} = file:eval(Name ++ ".nonexistent"),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

path_eval(suite) ->
    [];
path_eval(doc) ->
    [];
path_eval(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    FileName = atom_to_list(file_SUITE) ++ "_path_eval.fil",
    Name = filename:join(RootDir, FileName),
    {ok,Fd1} = file:open(Name, write),
    io:format(Fd1, "put(evaluated_ok,true).\n", []),
    ok = file:close(Fd1),
    {ok,Dir} =
        file:path_eval([filename:join(RootDir, "dir1"),
                        filename:join(RootDir, ".."),
                        filename:join(RootDir, "dir2"),
                        RootDir],
                       FileName),
    true = get(evaluated_ok),
    true = lists:prefix(RootDir, Dir),
    {ok,Fd2} = file:open(Name, write),
    io:format(Fd2, "put(evaluated_ok,R).\n", []),
    ok = file:close(Fd2),
    {ok,_} =
        file:path_eval(["nosuch1","nosuch2"],
                       Name,
                       erl_eval:add_binding('R',
                                            true,
                                            erl_eval:new_bindings())),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

script1(suite) ->
    [];
script1(doc) ->
    "";
script1(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Name =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_script.fil"),
    {ok,Fd1} = file:open(Name, write),
    io:format(Fd1, "A = 11,\nB = 6,\nA+B. ", []),
    ok = file:close(Fd1),
    {ok,17} = file:script(Name),
    {ok,Fd2} = file:open(Name, write),
    io:format(Fd2, "A = 11,\nA+B. ", []),
    ok = file:close(Fd2),
    {ok,17} =
        file:script(Name,
                    erl_eval:add_binding('B',
                                         6,
                                         erl_eval:new_bindings())),
    {ok,Fd3} = file:open(Name, write),
    io:format(Fd3, "A = 11,\nB = six,\nA+B. ", []),
    ok = file:close(Fd3),
    {error,{_,_,_} = Msg} = file:script(Name),
    io:format("Errmsg1: ~p", [Msg]),
    {error,enoent} = file:script(Name ++ ".nonexistent"),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

path_script(suite) ->
    [];
path_script(doc) ->
    [];
path_script(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    FileName = atom_to_list(file_SUITE) ++ "_path_script.fil",
    Name = filename:join(RootDir, FileName),
    {ok,Fd1} = file:open(Name, write),
    io:format(Fd1, "A = 11,\nB = 6,\nA+B.\n", []),
    ok = file:close(Fd1),
    {ok,17,Dir} =
        file:path_script([filename:join(RootDir, "dir1"),
                          filename:join(RootDir, ".."),
                          filename:join(RootDir, "dir2"),
                          RootDir],
                         FileName),
    true = lists:prefix(RootDir, Dir),
    {ok,Fd2} = file:open(Name, write),
    io:format(Fd2, "A = 11,\nA+B.", []),
    ok = file:close(Fd2),
    {ok,17,Dir} =
        file:path_script(["nosuch1","nosuch2"],
                         Name,
                         erl_eval:add_binding('B',
                                              6,
                                              erl_eval:new_bindings())),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

truncate(suite) ->
    [];
truncate(doc) ->
    [];
truncate(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Name =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_truncate.fil"),
    MyData = "0123456789abcdefghijklmnopqrstuvxyz",
    ok = file:write_file(Name, MyData),
    {ok,Fd} = file:open(Name, read_write),
    {ok,10} = file:position(Fd, 10),
    ok = file:truncate(Fd),
    ok = file:close(Fd),
    Expected = list_to_binary("0123456789"),
    {ok,Expected} = file:read_file(Name),
    {ok,Fd2} = file:open(Name, read),
    {ok,5} = file:position(Fd2, 5),
    {error,_} = file:truncate(Fd2),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

datasync(suite) ->
    [];
datasync(doc) ->
    "Tests that ?FILE_MODULE:datasync/1 at least doesn't crash.";
datasync(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    PrivDir = test_server:lookup_config(priv_dir, Config),
    Sync =
        filename:join(PrivDir, atom_to_list(file_SUITE) ++ "_sync.fil"),
    {ok,Fd} = file:open(Sync, [write,raw]),
    ok = file:datasync(Fd),
    ok = file:close(Fd),
    {ok,Fd2} = file:open(Sync, [write]),
    ok = file:datasync(Fd2),
    ok = file:close(Fd2),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

sync(suite) ->
    [];
sync(doc) ->
    "Tests that ?FILE_MODULE:sync/1 at least doesn't crash.";
sync(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    PrivDir = test_server:lookup_config(priv_dir, Config),
    Sync =
        filename:join(PrivDir, atom_to_list(file_SUITE) ++ "_sync.fil"),
    {ok,Fd} = file:open(Sync, [write,raw]),
    ok = file:sync(Fd),
    ok = file:close(Fd),
    {ok,Fd2} = file:open(Sync, [write]),
    ok = file:sync(Fd2),
    ok = file:close(Fd2),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

advise(suite) ->
    [];
advise(doc) ->
    "Tests that ?FILE_MODULE:advise/4 at least doesn't crash.";
advise(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    PrivDir = test_server:lookup_config(priv_dir, Config),
    Advise =
        filename:join(PrivDir,
                      atom_to_list(file_SUITE) ++ "_advise.fil"),
    Line1 = "Hello\n",
    Line2 = "World!\n",
    {ok,Fd} = file:open(Advise, [write]),
    ok = file:advise(Fd, 0, 0, normal),
    ok = io:format(Fd, "~s", [Line1]),
    ok = io:format(Fd, "~s", [Line2]),
    ok = file:close(Fd),
    {ok,Fd2} = file:open(Advise, [write]),
    ok = file:advise(Fd2, 0, 0, random),
    ok = io:format(Fd2, "~s", [Line1]),
    ok = io:format(Fd2, "~s", [Line2]),
    ok = file:close(Fd2),
    {ok,Fd3} = file:open(Advise, [write]),
    ok = file:advise(Fd3, 0, 0, sequential),
    ok = io:format(Fd3, "~s", [Line1]),
    ok = io:format(Fd3, "~s", [Line2]),
    ok = file:close(Fd3),
    {ok,Fd4} = file:open(Advise, [write]),
    ok = file:advise(Fd4, 0, 0, will_need),
    ok = io:format(Fd4, "~s", [Line1]),
    ok = io:format(Fd4, "~s", [Line2]),
    ok = file:close(Fd4),
    {ok,Fd5} = file:open(Advise, [write]),
    ok = file:advise(Fd5, 0, 0, dont_need),
    ok = io:format(Fd5, "~s", [Line1]),
    ok = io:format(Fd5, "~s", [Line2]),
    ok = file:close(Fd5),
    {ok,Fd6} = file:open(Advise, [write]),
    ok = file:advise(Fd6, 0, 0, no_reuse),
    ok = io:format(Fd6, "~s", [Line1]),
    ok = io:format(Fd6, "~s", [Line2]),
    ok = file:close(Fd6),
    {ok,Fd7} = file:open(Advise, [write]),
    {error,einval} = file:advise(Fd7, 0, 0, bad_advise),
    ok = file:close(Fd7),
    {ok,Fd8} = file:open(Advise, [write]),
    ok = io:format(Fd8, "~s", [Line1]),
    ok = io:format(Fd8, "~s", [Line2]),
    ok = file:close(Fd8),
    {ok,Fd9} = file:open(Advise, [read]),
    Offset = 0,
    Length = length(Line1) + length(Line2),
    ok = file:advise(Fd9, Offset, Length, sequential),
    {ok,Line1} = file:read_line(Fd9),
    {ok,Line2} = file:read_line(Fd9),
    eof = file:read_line(Fd9),
    ok = file:close(Fd9),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

allocate(suite) ->
    [];
allocate(doc) ->
    "Tests that ?FILE_MODULE:allocate/3 at least doesn't crash.";
allocate(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    PrivDir = test_server:lookup_config(priv_dir, Config),
    Allocate =
        filename:join(PrivDir,
                      atom_to_list(file_SUITE) ++ "_allocate.fil"),
    Line1 = "Hello\n",
    Line2 = "World!\n",
    {ok,Fd} = file:open(Allocate, [write,binary]),
    allocate_and_assert(Fd, 1, iolist_size([Line1,Line2])),
    ok = io:format(Fd, "~s", [Line1]),
    ok = io:format(Fd, "~s", [Line2]),
    ok = file:close(Fd),
    {ok,Fd2} = file:open(Allocate, [write,binary]),
    allocate_and_assert(Fd2, 1, iolist_size(Line1)),
    ok = io:format(Fd2, "~s", [Line1]),
    ok = io:format(Fd2, "~s", [Line2]),
    ok = file:close(Fd2),
    {ok,Fd3} = file:open(Allocate, [write,binary]),
    allocate_and_assert(Fd3, 1, iolist_size(Line1) + 1),
    ok = io:format(Fd3, "~s", [Line1]),
    ok = io:format(Fd3, "~s", [Line2]),
    ok = file:close(Fd3),
    {ok,Fd4} = file:open(Allocate, [write,binary]),
    allocate_and_assert(Fd4, 1, 4 * iolist_size([Line1,Line2])),
    ok = io:format(Fd4, "~s", [Line1]),
    ok = io:format(Fd4, "~s", [Line2]),
    ok = file:close(Fd4),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

allocate_and_assert(Fd, Offset, Length) ->
    Result = file:allocate(Fd, Offset, Length),
    case os:type() of
        {win32,_} ->
            {error,enotsup} = Result;
        _ ->
            _ = Result
    end.

delete(suite) ->
    [];
delete(doc) ->
    [];
delete(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Name =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_delete.fil"),
    {ok,Fd1} = file:open(Name, write),
    io:format(Fd1, "ok.\n", []),
    ok = file:close(Fd1),
    {ok,Fd2} = file:open(Name, read),
    ok = file:close(Fd2),
    ok = file:delete(Name),
    {error,_} = file:open(Name, read),
    {error,enoent} = file:delete(Name),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

rename(suite) ->
    [];
rename(doc) ->
    [];
rename(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    FileName1 = atom_to_list(file_SUITE) ++ "_rename.fil",
    FileName2 = atom_to_list(file_SUITE) ++ "_rename.ful",
    Name1 = filename:join(RootDir, FileName1),
    Name2 = filename:join(RootDir, FileName2),
    {ok,Fd1} = file:open(Name1, write),
    ok = file:close(Fd1),
    ok = file:rename(Name1, Name2),
    {error,_} = file:open(Name1, read),
    {ok,Fd2} = file:open(Name2, read),
    ok = file:close(Fd2),
    ok = file:rename(Name2, Name2),
    {error,enoent} = file:rename(Name1, Name2),
    {error,badarg} = file:rename(Name1, {foo,bar}),
    DirName1 =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_rename_dir"),
    DirName2 =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_second_rename_dir"),
    Name1foo = filename:join(DirName1, "foo.fil"),
    Name2foo = filename:join(DirName2, "foo.fil"),
    Name2bar = filename:join(DirName2, "bar.dir"),
    ok = file:make_dir(DirName1),
    expect({error,eisdir}, {error,eexist}, file:rename(Name2, DirName1)),
    ok = file:rename(Name2, Name1foo),
    ok = file:rename(DirName1, DirName2),
    {ok,Fd3} = file:open(Name2foo, read),
    ok = file:close(Fd3),
    {error,Msg1} = file:rename(DirName2, Name2bar),
    io:format("Errmsg1: ~p", [Msg1]),
    {error,Msg2} = file:rename(DirName2, Name2foo),
    io:format("Errmsg2: ~p", [Msg2]),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

names(suite) ->
    [];
names(doc) ->
    [];
names(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(5)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    FileName = "foo1.fil",
    Name1 = filename:join(RootDir, FileName),
    Name2 = [RootDir,"/","foo1",".","fil"],
    Name3 = [RootDir,"/",foo,$1,[[[],[],'.']],"f",il],
    Name4 = list_to_atom(Name1),
    {ok,Fd0} = file:open(Name1, write),
    ok = file:close(Fd0),
    {ok,Fd1} = file:open(Name1, read),
    ok = file:close(Fd1),
    {ok,Fd2f} = file:open(lists:flatten(Name2), read),
    ok = file:close(Fd2f),
    {ok,Fd2} = file:open(Name2, read),
    ok = file:close(Fd2),
    {ok,Fd3} = file:open(Name3, read),
    ok = file:close(Fd3),
    {ok,Fd4} = file:open(Name4, read),
    ok = file:close(Fd4),
    Path1 = RootDir,
    Path2 = [RootDir],
    Path3 = ['',[],[RootDir,[[]]]],
    Path4 = list_to_atom(Path1),
    {ok,Fd11,_} = file:path_open([Path1], FileName, read),
    ok = file:close(Fd11),
    {ok,Fd12,_} = file:path_open([Path2], FileName, read),
    ok = file:close(Fd12),
    {ok,Fd13,_} = file:path_open([Path3], FileName, read),
    ok = file:close(Fd13),
    {ok,Fd14,_} = file:path_open([Path4], FileName, read),
    ok = file:close(Fd14),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

e_delete(suite) ->
    [];
e_delete(doc) ->
    [];
e_delete(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Base =
        filename:join(RootDir, atom_to_list(file_SUITE) ++ "_e_delete"),
    ok = file:make_dir(Base),
    {error,enoent} = file:delete(filename:join(Base, "non_existing")),
    {error,eperm} = file:delete(Base),
    Afile = filename:join(Base, "a_file"),
    ok = file:write_file(Afile, "hello\n"),
    {error,E} =
        expect({error,enotdir},
               {error,enoent},
               file:delete(filename:join(Afile, "another_file"))),
    io:format("Result: ~p~n", [E]),
    case os:type() of
        {unix,_} ->
            file:write_file_info(Base, #file_info{mode = 0}),
            {error,eacces} = file:delete(Afile),
            file:write_file_info(Base, #file_info{mode = 384});
        {win32,_} ->
            {error,eacces} = file:delete("nul")
    end,
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

e_rename(suite) ->
    [];
e_rename(doc) ->
    [];
e_rename(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Base =
        filename:join(RootDir, atom_to_list(file_SUITE) ++ "_e_rename"),
    ok = file:make_dir(Base),
    EmptyDir = filename:join(Base, "empty_dir"),
    ok = file:make_dir(EmptyDir),
    NonEmptyDir = filename:join(Base, "non_empty_dir"),
    ok = file:make_dir(NonEmptyDir),
    ok =
        file:write_file(filename:join(NonEmptyDir, "a_file"), "hello\n"),
    ADirectory = filename:join(Base, "a_directory"),
    ok = file:make_dir(ADirectory),
    ok =
        file:write_file(filename:join(ADirectory, "a_file"),
                        "howdy\n\n"),
    File = filename:join(Base, "just_a_file"),
    ok = file:write_file(File, "anything goes\n\n"),
    {error,eexist} = file:rename(ADirectory, NonEmptyDir),
    {error,einval} = file:rename("/", "arne"),
    {error,einval} = file:rename(Base, filename:join(Base, "new_name")),
    expect({error,eexist}, {error,eisdir}, file:rename(File, EmptyDir)),
    expect({error,eexist},
           {error,eisdir},
           file:rename(File, NonEmptyDir)),
    NonExistingFile = filename:join(Base, "non_existing_file"),
    {error,enoent} = file:rename(NonExistingFile, NonEmptyDir),
    expect({error,eexist},
           {error,enotdir},
           file:rename(ADirectory, File)),
    Comment =
        case os:type() of
            {unix,_} ->
                OtherFs = "/tmp",
                NameOnOtherFs =
                    filename:join(OtherFs, filename:basename(File)),
                {ok,Com} =
                    case file:rename(File, NameOnOtherFs) of
                        {error,exdev} ->
                            {ok,ok};
                        ok ->
                            {ok,
                             {comment,
                              "Moving between filesystems suceeded, fil"
                              "es are probably in the same filesystem!"}};
                        {error,eperm} ->
                            {ok,
                             {comment,
                              "SBS! You don't have the permission to do"
                              " this test!"}};
                        Else ->
                            Else
                    end,
                Com;
            {win32,_} ->
                ok
        end,
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    Comment.

e_make_dir(suite) ->
    [];
e_make_dir(doc) ->
    [];
e_make_dir(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Base =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_e_make_dir"),
    ok = file:make_dir(Base),
    {error,enoent} = file:make_dir(filename:join([Base,"a","b"])),
    Afile = filename:join(Base, "a_directory"),
    ok = file:write_file(Afile, "hello\n"),
    case file:make_dir(filename:join(Afile, "another_directory")) of
        {error,enotdir} ->
            io:format("Result: enotdir");
        {error,enoent} ->
            io:format("Result: enoent")
    end,
    case os:type() of
        {unix,_} ->
            file:write_file_info(Base, #file_info{mode = 0}),
            {error,eacces} = file:make_dir(filename:join(Base, "xxxx")),
            file:write_file_info(Base, #file_info{mode = 384});
        {win32,_} ->
            ok
    end,
    test_server:timetrap_cancel(Dog),
    ok.

e_del_dir(suite) ->
    [];
e_del_dir(doc) ->
    [];
e_del_dir(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Base = test_server:temp_name(filename:join(RootDir, "e_del_dir")),
    io:format("Base: ~p", [Base]),
    ok = file:make_dir(Base),
    {error,enoent} = file:del_dir(filename:join(Base, "non_existing")),
    Afile = filename:join(Base, "a_directory"),
    ok = file:write_file(Afile, "hello\n"),
    {error,E1} =
        expect({error,enotdir},
               {error,enoent},
               file:del_dir(filename:join(Afile, "another_directory"))),
    io:format("Result: ~p", [E1]),
    {error,E2} =
        expect({error,enotempty},
               {error,eexist},
               {error,eacces},
               file:del_dir(Base)),
    io:format("Result: ~p", [E2]),
    {error,E3} =
        expect({error,einval},
               {error,eperm},
               {error,eacces},
               {error,ebusy},
               file:del_dir(".")),
    io:format("Result: ~p", [E3]),
    case os:type() of
        {unix,_} ->
            ADirectory = filename:join(Base, "no_perm"),
            ok = file:make_dir(ADirectory),
            file:write_file_info(Base, #file_info{mode = 0}),
            {error,eacces} = file:del_dir(ADirectory),
            file:write_file_info(Base, #file_info{mode = 384});
        {win32,_} ->
            ok
    end,
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

read_compressed_cooked(Config) when is_list(Config) ->
    Data = test_server:lookup_config(data_dir, Config),
    Real = filename:join(Data, "realmen.html.gz"),
    {ok,Fd} = file:open(Real, [read,compressed]),
    try_read_file_list(Fd).

read_compressed_cooked_binary(Config) when is_list(Config) ->
    Data = test_server:lookup_config(data_dir, Config),
    Real = filename:join(Data, "realmen.html.gz"),
    {ok,Fd} = file:open(Real, [read,compressed,binary]),
    try_read_file_binary(Fd).

read_not_really_compressed(Config) when is_list(Config) ->
    Data = test_server:lookup_config(data_dir, Config),
    Priv = test_server:lookup_config(priv_dir, Config),
    Real = filename:join(Data, "realmen.html"),
    RealPriv =
        filename:join(Priv, atom_to_list(file_SUITE) ++ "_realmen.html"),
    {ok,RealDataBin} = file:read_file(Real),
    RealData = remove_crs(binary_to_list(RealDataBin), []),
    ok = file:write_file(RealPriv, RealData),
    {ok,Fd} = file:open(RealPriv, [read,compressed]),
    try_read_file_list(Fd).

remove_crs([$\r|Rest], Result) ->
    remove_crs(Rest, Result);
remove_crs([C|Rest], Result) ->
    remove_crs(Rest, [C|Result]);
remove_crs([], Result) ->
    lists:reverse(Result).

try_read_file_list(Fd) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    {ok,0} = file:position(Fd, 0),
    {ok,0} = file:position(Fd, {cur,0}),
    ShouldBe = "<TITLE>Real Programmers Don't Use PASCAL</TITLE>\n",
    ShouldBe = io:get_line(Fd, ''),
    {ok,381} = file:position(Fd, 381),
    Back =
        "Back in the good old days -- the \"Golden Era\" "
        ++
        "of computers, it was\n",
    Back = io:get_line(Fd, ''),
    {ok,CurPos} = file:position(Fd, {cur,0}),
    RealPos = 4273,
    {ok,RealPos} = file:position(Fd, {cur,RealPos - CurPos}),
    RealProg = "<LI> Real Programmers aren't afraid to use GOTOs.\n",
    RealProg = io:get_line(Fd, ''),
    AfterTitle = length("<TITLE>"),
    {ok,AfterTitle} = file:position(Fd, AfterTitle),
    Title = "Real Programmers Don't Use PASCAL</TITLE>\n",
    Title = io:get_line(Fd, ''),
    {ok,_} = file:position(Fd, 25000),
    file:close(Fd),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

try_read_file_binary(Fd) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    {ok,0} = file:position(Fd, 0),
    {ok,0} = file:position(Fd, {cur,0}),
    ShouldBe = <<"<TITLE>Real Programmers Don't Use PASCAL</TITLE>\n">>,
    ShouldBe = io:get_line(Fd, ''),
    {ok,381} = file:position(Fd, 381),
    Back =
        <<"Back in the good old days -- the \"Golden Era\" of computers"
          ", it was\n">>,
    Back = io:get_line(Fd, ''),
    {ok,CurPos} = file:position(Fd, {cur,0}),
    RealPos = 4273,
    {ok,RealPos} = file:position(Fd, {cur,RealPos - CurPos}),
    RealProg = <<"<LI> Real Programmers aren't afraid to use GOTOs.\n">>,
    RealProg = io:get_line(Fd, ''),
    AfterTitle = length("<TITLE>"),
    {ok,AfterTitle} = file:position(Fd, AfterTitle),
    Title = <<"Real Programmers Don't Use PASCAL</TITLE>\n">>,
    Title = io:get_line(Fd, ''),
    file:close(Fd),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

read_cooked_tar_problem(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    Data = test_server:lookup_config(data_dir, Config),
    ProblemFile = filename:join(Data, "cooked_tar_problem.tar.gz"),
    {ok,Fd} = file:open(ProblemFile, [read,compressed,binary]),
    {ok,34304} = file:position(Fd, 34304),
    {ok,Bin} = file:read(Fd, 512),
    512 = byte_size(Bin),
    {ok,34304 + 512 + 1024} = file:position(Fd, {cur,1024}),
    ok = file:close(Fd),
    test_server:timetrap_cancel(Dog),
    ok.

write_compressed(suite) ->
    [];
write_compressed(doc) ->
    [];
write_compressed(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    Priv = test_server:lookup_config(priv_dir, Config),
    MyFile = filename:join(Priv, atom_to_list(file_SUITE) ++ "_test.gz"),
    {ok,Fd} = file:open(MyFile, [write,compressed]),
    {ok,0} = file:position(Fd, 0),
    Prefix = "hello\n",
    End = "end\n",
    ok = io:put_chars(Fd, Prefix),
    {ok,143} = file:position(Fd, 143),
    ok = io:put_chars(Fd, End),
    ok = file:close(Fd),
    {ok,Fd1} = file:open(MyFile, [read,compressed]),
    Prefix = io:get_line(Fd1, ''),
    Second = lists:duplicate(143 - length(Prefix), 0) ++ End,
    Second = io:get_line(Fd1, ''),
    ok = file:close(Fd1),
    {ok,Contents} = file:read_file(MyFile),
    <<"hello\n",0:137/unit:8,"end\n">> = zlib:gunzip(Contents),
    TotalSize = 143 + length(End),
    case file:read_file_info(MyFile) of
        {ok,#file_info{size = Size}} when Size < TotalSize ->
            ok;
        {ok,#file_info{size = Size}} when Size == TotalSize ->
            test_server:fail(file_not_compressed)
    end,
    {ok,Fd2} = file:open(MyFile, [write,compressed]),
    NewString = "aaaaaaaaaaa",
    ok = io:put_chars(Fd2, NewString),
    ok = file:close(Fd2),
    {ok,Fd3} = file:open(MyFile, [read,compressed]),
    {ok,NewString} = file:read(Fd3, 1024),
    ok = file:close(Fd3),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

catenated_gzips(Config) when is_list(Config) ->
    Priv = test_server:lookup_config(priv_dir, Config),
    MyFile = filename:join(Priv, "file_SUITE" ++ "_test.gz"),
    First = "Hello, all good men going to search parties. ",
    Second = "Now I really need your help.",
    All = iolist_to_binary([First|Second]),
    Cat = [zlib:gzip(First),zlib:gzip(Second)],
    ok = file:write_file(MyFile, Cat),
    {ok,Fd} = file:open(MyFile, [read,compressed,binary]),
    {ok,All} = file:read(Fd, 100000),
    ok = file:close(Fd),
    ok.

compress_errors(suite) ->
    [];
compress_errors(doc) ->
    [];
compress_errors(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    DataDir =
        filename:dirname(filename:join(test_server:lookup_config(data_dir,
                                                                 Config),
                                       "x")),
    DataDirSlash = DataDir ++ "/",
    {error,enoent} = file:open("non_existing__", [compressed,read]),
    {error,einval} =
        file:open("non_existing__", [compressed,read,write]),
    {error,einval} =
        file:open("non_existing__", [compressed,read,append]),
    {error,einval} =
        file:open("non_existing__", [compressed,write,append]),
    {error,E1} = file:open(DataDir, [compressed,read]),
    {error,E2} = file:open(DataDirSlash, [compressed,read]),
    {error,E3} = file:open(DataDir, [compressed,write]),
    {error,E4} = file:open(DataDirSlash, [compressed,write]),
    {eisdir,eisdir,eisdir,eisdir} = {E1,E2,E3,E4},
    Corrupted = filename:join(DataDir, "corrupted.gz"),
    {ok,Fd} = file:open(Corrupted, [read,compressed]),
    {error,eio} = file:read(Fd, 100),
    file:close(Fd),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

compress_async_crash(suite) ->
    [];
compress_async_crash(doc) ->
    [];
compress_async_crash(Config) when is_list(Config) ->
    DataDir = test_server:lookup_config(data_dir, Config),
    Path = filename:join(DataDir, "test.gz"),
    ExpectedData = <<"qwerty">>,
    _ = file:delete(Path),
    {ok,Fd} = file:open(Path, [write,binary,compressed]),
    ok = file:write(Fd, ExpectedData),
    ok = file:close(Fd),
    ok = compress_async_crash_loop(10000, Path, ExpectedData),
    ok = file:delete(Path),
    ok.

compress_async_crash_loop(0, _Path, _ExpectedData) ->
    ok;
compress_async_crash_loop(N, Path, ExpectedData) ->
    Parent = self(),
    {Pid,Ref} =
        spawn_monitor(fun() ->
                             {ok,Fd} =
                                 file:open(Path,
                                           [read,compressed,raw,binary]),
                             Len = byte_size(ExpectedData),
                             Parent ! {self(),continue},
                             {ok,ExpectedData} = file:read(Fd, Len),
                             ok = file:close(Fd),
                             receive
                                 foobar ->
                                     ok
                             end
                      end),
    receive
        {Pid,continue} ->
            exit(Pid, shutdown),
            receive
                {'DOWN',Ref,_,_,Reason} ->
                    shutdown = Reason
            end;
        {'DOWN',Ref,_,_,Reason2} ->
            test_server:fail({worker_exited,Reason2})
    after
        60000 ->
            exit(Pid, shutdown),
            demonitor(Ref, [flush]),
            test_server:fail(worker_timeout)
    end,
    compress_async_crash_loop(N - 1, Path, ExpectedData).

altname(doc) ->
    "Test the file:altname/1 function";
altname(suite) ->
    [];
altname(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    NewDir =
        filename:join(RootDir, "long alternative path name with spaces"),
    ok = file:make_dir(NewDir),
    Name = filename:join(NewDir, "a_file_with_long_name"),
    ShortName = filename:join(NewDir, "short"),
    NonexName = filename:join(NewDir, "nonexistent"),
    ok = file:write_file(Name, "some contents\n"),
    ok = file:write_file(ShortName, "some contents\n"),
    Result =
        case file:altname(NewDir) of
            {error,enotsup} ->
                {skipped,"Altname not supported on this platform"};
            {ok,"LONGAL~1"} ->
                {ok,"A_FILE~1"} = file:altname(Name),
                {ok,"C:/"} = file:altname("C:/"),
                {ok,"C:\\"} = file:altname("C:\\"),
                {error,enoent} = file:altname(NonexName),
                {ok,"short"} = file:altname(ShortName),
                ok
        end,
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    Result.

make_link(doc) ->
    "Test creating a hard link.";
make_link(suite) ->
    [];
make_link(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    NewDir =
        filename:join(RootDir, atom_to_list(file_SUITE) ++ "_make_link"),
    ok = file:make_dir(NewDir),
    Name = filename:join(NewDir, "a_file"),
    ok = file:write_file(Name, "some contents\n"),
    Alias = filename:join(NewDir, "an_alias"),
    Result =
        case file:make_link(Name, Alias) of
            {error,enotsup} ->
                {skipped,"Links not supported on this platform"};
            ok ->
                {ok,Info} = file:read_link_info(Name),
                {ok,Info} = file:read_link_info(Alias),
                #file_info{links = 2,type = regular} = Info,
                {error,eexist} = file:make_link(Name, Alias),
                ok
        end,
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    Result.

read_link_info_for_non_link(doc) ->
    "Test that reading link info for an ordinary file or directory work"
    "s (on all platforms).";
read_link_info_for_non_link(suite) ->
    [];
read_link_info_for_non_link(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    {ok,#file_info{type = directory}} = file:read_link_info("."),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

symlinks(doc) ->
    "Test operations on symbolic links (for Unix).";
symlinks(suite) ->
    [];
symlinks(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    {error,_} = file:read_link(lists:duplicate(10000, $a)),
    {error,_} = file:read_link_all(lists:duplicate(10000, $a)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    NewDir =
        filename:join(RootDir, atom_to_list(file_SUITE) ++ "_symlinks"),
    ok = file:make_dir(NewDir),
    Name = filename:join(NewDir, "a_plain_file"),
    ok = file:write_file(Name, "some stupid content\n"),
    Alias = filename:join(NewDir, "a_symlink_alias"),
    Result =
        case file:make_symlink(Name, Alias) of
            {error,enotsup} ->
                {skipped,"Links not supported on this platform"};
            ok ->
                {ok,Info1} = file:read_file_info(Name),
                {ok,Info1} = file:read_file_info(Alias),
                {ok,Info1} = file:read_link_info(Name),
                #file_info{links = 1,type = regular} = Info1,
                {ok,Info2} = file:read_link_info(Alias),
                #file_info{links = 1,type = symlink} = Info2,
                {ok,Name} = file:read_link(Alias),
                {ok,Name} = file:read_link_all(Alias),
                rm_rf(file, NewDir),
                ok
        end,
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    Result.

copy(doc) ->
    [];
copy(suite) ->
    [];
copy(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Name1 =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_copy_1.txt"),
    Line = "The quick brown fox jumps over a lazy dog. 0123456789\n",
    Len = length(Line),
    {ok,Handle1} = file:open(Name1, [write]),
    {_,Size1} =
        iterate({0,0},
                done,
                fun({_,S}) when S >= 128 * 1024 ->
                       done;
                   ({N,S}) ->
                       H = integer_to_list(N),
                       ok = file:write(Handle1, [H," ",Line]),
                       {N + 1,S + length(H) + 1 + Len}
                end),
    file:close(Handle1),
    Name2 =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_copy_2.txt"),
    {ok,Size1} = file:copy(Name1, Name2),
    Name3 =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_copy_3.txt"),
    {ok,Handle3} = file:open(Name3, [raw,write,binary]),
    {ok,Size1} = file:copy(Name1, Handle3),
    {ok,Handle2} = file:open(Name2, [read,binary]),
    {ok,Size1} = file:copy(Handle2, Handle3),
    ok = file:close(Handle3),
    ok = file:close(Handle2),
    Name4 =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_copy_4.txt"),
    {ok,Handle4} = file:open(Name4, [write,binary]),
    {ok,Size1} = file:copy(Name1, Handle4),
    {ok,Handle5} = file:open(Name2, [raw,read,binary]),
    {ok,Size1} = file:copy(Handle5, Handle4),
    ok = file:close(Handle5),
    ok = file:close(Handle4),
    {ok,Handle1a} = file:open(Name1, [raw,read]),
    {ok,Handle2a} = file:open(Name2, [raw,read]),
    true =
        stream_cmp(fd_stream_factory([Handle1a]),
                   fd_stream_factory([Handle2a])),
    {ok,0} = file:position(Handle1a, 0),
    {ok,0} = file:position(Handle2a, 0),
    {ok,Handle3a} = file:open(Name3, [raw,read]),
    true =
        stream_cmp(fd_stream_factory([Handle1a,Handle2a]),
                   fd_stream_factory([Handle2a])),
    ok = file:close(Handle1a),
    ok = file:close(Handle2a),
    ok = file:close(Handle3a),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

fd_stream_factory([]) ->
    [];
fd_stream_factory([Fd|T] = L) ->
    fun() ->
           case file:read(Fd, 8192) of
               {ok,Data} when is_binary(Data) ->
                   binary_to_list(Data) ++ fd_stream_factory(L);
               {ok,Data} when is_list(Data) ->
                   Data ++ fd_stream_factory(L);
               eof ->
                   fd_stream_factory(T);
               {error,_} = Error ->
                   Error
           end
    end.

stream_cmp(F1, F2) when is_function(F1), is_function(F2) ->
    stream_cmp(F1(), F2());
stream_cmp(F, X) when is_function(F) ->
    stream_cmp(F(), X);
stream_cmp(X, F) when is_function(F) ->
    stream_cmp(X, F());
stream_cmp({error,_} = Error, _) ->
    Error;
stream_cmp(_, {error,_} = Error) ->
    Error;
stream_cmp([], []) ->
    true;
stream_cmp([], [_|_]) ->
    false;
stream_cmp([_|_], []) ->
    false;
stream_cmp([H|T1], [H|T2]) ->
    stream_cmp(T1, T2).

new_slave(_RootDir, Cwd) ->
    L = "qwertyuiopasdfghjklzxcvbnm",
    N = length(L),
    {ok,Cwd} = file:get_cwd(),
    {error,enotsup} = file:get_cwd("C:"),
    {ok,FD1} = file:open("file1.txt", write),
    ok = file:close(FD1),
    {ok,FD2} =
        file:open("file1.txt",
                  [write,
                   append,
                   binary,
                   compressed,
                   delayed_write,
                   {delayed_write,0,0},
                   read_ahead,
                   {read_ahead,0}]),
    ok = file:write(FD2, L),
    ok = file:close(FD2),
    {ok,N2} = file:copy("file1.txt", "file2.txt"),
    io:format("Size ~p, compressed ~p.~n", [N,N2]),
    {ok,FD3} = file:open("file2.txt", [binary,compressed]),
    {ok,L} = file:read(FD3, N + 1),
    ok = file:close(FD3),
    ok = file:delete("file1.txt"),
    ok = file:delete("file2.txt"),
    [] = flush(),
    ok.

old_slave(_RootDir, Cwd) ->
    L = "qwertyuiopasdfghjklzxcvbnm",
    N = length(L),
    {ok,Cwd} = file:get_cwd(),
    {error,enotsup} = file:get_cwd("C:"),
    {ok,FD1} = file:open("file1.txt", write),
    ok = file:close(FD1),
    {ok,FD2} = file:open("file1.txt", [write,binary,compressed]),
    ok = file:write(FD2, L),
    ok = file:close(FD2),
    {ok,FD3} = file:open("file1.txt", [write,append]),
    ok = file:close(FD3),
    {ok,FD4} = file:open("file1.txt", [binary,compressed]),
    {ok,L} = file:read(FD4, N + 1),
    ok = file:close(FD4),
    ok = file:delete("file1.txt"),
    [] = flush(),
    ok.

run_test(Test, Args) ->
    case catch apply(file_SUITE, Test, Args) of
        {'EXIT',_} = Exit ->
            {done,Exit,get(test_server_loc)};
        Result ->
            {done,Result}
    end.

delayed_write(suite) ->
    [];
delayed_write(doc) ->
    ["Tests the file open option {delayed_write, Size, Delay}"];
delayed_write(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(20)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    File =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_delayed_write.txt"),
    Data1 = "asdfghjkl",
    Data2 = "qwertyuio",
    Data3 = "zxcvbnm,.",
    Size = length(Data1),
    Size = length(Data2),
    Size = length(Data3),
    Data1Data1 = Data1 ++ Data1,
    Data1Data1Data1 = Data1Data1 ++ Data1,
    Data1Data1Data1Data1 = Data1Data1 ++ Data1Data1,
    {ok,Fd1} = file:open(File, [write,{delayed_write,Size + 1,2000}]),
    ok = file:write(Fd1, Data1),
    test_server:sleep(1000),
    {ok,Fd2} = file:open(File, [read]),
    eof = file:read(Fd2, 1),
    ok = file:write(Fd1, Data1),
    test_server:sleep(1000),
    {ok,Data1Data1} = file:pread(Fd2, bof, 2 * Size + 1),
    ok = file:write(Fd1, Data1),
    test_server:sleep(3000),
    {ok,Data1Data1Data1} = file:pread(Fd2, bof, 3 * Size + 1),
    ok = file:write(Fd1, Data1),
    ok = file:close(Fd1),
    test_server:sleep(1000),
    {ok,Data1Data1Data1Data1} = file:pread(Fd2, bof, 4 * Size + 1),
    ok = file:close(Fd2),
    Parent = self(),
    Fun =
        fun() ->
               Child = self(),
               Test =
                   fun() ->
                          {ok,Fd} =
                              file:open(File, [raw,write,delayed_write]),
                          ok = file:write(Fd, Data1),
                          Parent ! {Child,wrote},
                          receive
                              {Parent,continue,Reason} ->
                                  {ok,Reason}
                          end
                   end,
               case catch Test() of
                   {ok,Reason} ->
                       exit(Reason);
                   Unknown ->
                       exit({Unknown,get(test_server_loc)})
               end
        end,
    Child1 = spawn(Fun),
    Mref1 = monitor(process, Child1),
    receive
        {Child1,wrote} ->
            ok;
        {'DOWN',Mref1,_,_,_} = Down1a ->
            test_server:fail(Down1a)
    end,
    test_server:sleep(1000),
    {ok,Fd3} = file:open(File, [read]),
    eof = file:read(Fd3, 1),
    Child1 ! {Parent,continue,normal},
    receive
        {'DOWN',Mref1,process,Child1,normal} ->
            ok;
        {'DOWN',Mref1,_,_,_} = Down1b ->
            test_server:fail(Down1b)
    end,
    test_server:sleep(1000),
    {ok,Data1} = file:pread(Fd3, bof, Size + 1),
    ok = file:close(Fd3),
    Child2 = spawn(Fun),
    Mref2 = monitor(process, Child2),
    receive
        {Child2,wrote} ->
            ok;
        {'DOWN',Mref2,_,_,_} = Down2a ->
            test_server:fail(Down2a)
    end,
    test_server:sleep(1000),
    {ok,Fd4} = file:open(File, [read]),
    eof = file:read(Fd4, 1),
    Child2 ! {Parent,continue,kill},
    receive
        {'DOWN',Mref2,process,Child2,kill} ->
            ok;
        {'DOWN',Mref2,_,_,_} = Down2b ->
            test_server:fail(Down2b)
    end,
    test_server:sleep(1000),
    eof = file:pread(Fd4, bof, 1),
    ok = file:close(Fd4),
    {ok,Fd5} = file:open(File, [raw,read,write,delayed_write]),
    ok = file:truncate(Fd5),
    ok = file:write(Fd5, [Data1|Data2]),
    {ok,0} = file:position(Fd5, bof),
    ok = file:write(Fd5, [Data3]),
    {ok,Data2} = file:read(Fd5, Size + 1),
    {ok,0} = file:position(Fd5, bof),
    Data3Data2 = Data3 ++ Data2,
    {ok,Data3Data2} = file:read(Fd5, 2 * Size + 1),
    ok = file:close(Fd5),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

pid2name(doc) ->
    "Tests file:pid2name/1.";
pid2name(suite) ->
    [];
pid2name(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    Base = test_server:temp_name(filename:join(RootDir, "pid2name_")),
    Name1 = [Base,'.txt'],
    Name2 = Base ++ ".txt",
    {ok,Pid} = file:open(Name1, [write]),
    {ok,Name2} = file:pid2name(Pid),
    undefined = file:pid2name(self()),
    ok = file:close(Pid),
    test_server:sleep(1000),
    false = is_process_alive(Pid),
    undefined = file:pid2name(Pid),
    test_server:timetrap_cancel(Dog),
    ok.

read_ahead(suite) ->
    [];
read_ahead(doc) ->
    ["Tests the file open option {read_ahead, Size}"];
read_ahead(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(20)),
    RootDir = test_server:lookup_config(priv_dir, Config),
    File =
        filename:join(RootDir,
                      atom_to_list(file_SUITE) ++ "_read_ahead.txt"),
    Data1 = "asdfghjkl",
    Data2 = "qwertyuio",
    Data3 = "zxcvbnm,.",
    Size = length(Data1),
    Size = length(Data2),
    Size = length(Data3),
    {ok,Fd1} = file:open(File, [write]),
    ok = file:write(Fd1, [Data1|Data1]),
    test_server:sleep(1000),
    {ok,Fd2} = file:open(File, [read,{read_ahead,2 * Size}]),
    {ok,Data1} = file:read(Fd2, Size),
    ok = file:pwrite(Fd1, Size, Data2),
    test_server:sleep(1000),
    {ok,Data1} = file:read(Fd2, Size),
    Data2Data2Data2 = Data2 ++ Data2 ++ Data2,
    ok = file:pwrite(Fd1, eof, Data2Data2Data2),
    test_server:sleep(1000),
    {ok,Data2Data2Data2} = file:read(Fd2, 3 * Size),
    ok = file:close(Fd1),
    ok = file:close(Fd2),
    {ok,Fd3} = file:open(File, [raw,write]),
    ok = file:write(Fd3, [Data1|Data1]),
    test_server:sleep(1000),
    {ok,Fd4} = file:open(File, [raw,read,read_ahead]),
    {ok,Data1} = file:read(Fd4, Size),
    ok = file:pwrite(Fd3, Size, Data2),
    test_server:sleep(1000),
    {ok,Data1} = file:read(Fd4, Size),
    ok = file:close(Fd3),
    ok = file:close(Fd4),
    {ok,Fd5} = file:open(File, [raw,read,write,read_ahead]),
    ok = file:truncate(Fd5),
    ok = file:write(Fd5, [Data1,Data1|Data3]),
    {ok,0} = file:position(Fd5, bof),
    {ok,Data1} = file:read(Fd5, Size),
    ok = file:write(Fd5, Data2),
    {ok,0} = file:position(Fd5, bof),
    Data1Data2Data3 = Data1 ++ Data2 ++ Data3,
    {ok,Data1Data2Data3} = file:read(Fd5, 3 * Size + 1),
    ok = file:close(Fd5),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

segment_read(suite) ->
    [];
segment_read(doc) ->
    ["Tests the segmenting of large reads"];
segment_read(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(60)),
    Name =
        filename:join(test_server:lookup_config(priv_dir, Config),
                      "file_SUITE" ++ "_segment_read"),
    SegSize = 256 * 1024,
    SegCnt = SegSize div 4,
    Cnt = 4 * SegCnt,
    ok = create_file(Name, Cnt),
    {ok,Bin} = file:read_file(Name),
    true = verify_bin(Bin, 0, Cnt),
    {ok,FD1} = file:open(Name, [read,raw,binary]),
    {ok,B1a} = file:read(FD1, SegSize),
    {ok,B1b} = file:read(FD1, SegSize),
    {ok,B1c} = file:read(FD1, SegSize),
    {ok,B1d} = file:read(FD1, SegSize),
    ok = file:close(FD1),
    true = verify_bin(B1a, 0 * SegCnt, SegCnt),
    true = verify_bin(B1b, 1 * SegCnt, SegCnt),
    true = verify_bin(B1c, 2 * SegCnt, SegCnt),
    true = verify_bin(B1d, 3 * SegCnt, SegCnt),
    {ok,FD2} = file:open(Name, [read,raw,binary]),
    {ok,B2a} = file:read(FD2, 1 * SegSize),
    {ok,B2b} = file:read(FD2, 2 * SegSize),
    {ok,B2c} = file:read(FD2, 2 * SegSize),
    ok = file:close(FD2),
    true = verify_bin(B2a, 0 * SegCnt, 1 * SegCnt),
    true = verify_bin(B2b, 1 * SegCnt, 2 * SegCnt),
    true = verify_bin(B2c, 3 * SegCnt, 1 * SegCnt),
    {ok,FD3} = file:open(Name, [read,raw,binary]),
    {ok,B3d} = file:pread(FD3, 3 * SegSize, SegSize),
    {ok,B3c} = file:pread(FD3, 2 * SegSize, SegSize),
    {ok,B3b} = file:pread(FD3, 1 * SegSize, SegSize),
    {ok,B3a} = file:pread(FD3, 0 * SegSize, SegSize),
    true = verify_bin(B3a, 0 * SegCnt, SegCnt),
    true = verify_bin(B3b, 1 * SegCnt, SegCnt),
    true = verify_bin(B3c, 2 * SegCnt, SegCnt),
    true = verify_bin(B3d, 3 * SegCnt, SegCnt),
    {ok,B3g} = file:pread(FD3, 3 * SegSize, 2 * SegSize),
    {ok,B3f} = file:pread(FD3, 1 * SegSize, 2 * SegSize),
    {ok,B3e} = file:pread(FD3, 0 * SegSize, 1 * SegSize),
    true = verify_bin(B3e, 0 * SegCnt, 1 * SegCnt),
    true = verify_bin(B3f, 1 * SegCnt, 2 * SegCnt),
    true = verify_bin(B3g, 3 * SegCnt, 1 * SegCnt),
    ok = file:close(FD3),
    {ok,FD5} = file:open(Name, [read,raw,binary]),
    {ok,[B5d,B5c,B5b,B5a]} =
        file:pread(FD5,
                   [{3 * SegSize,SegSize},
                    {2 * SegSize,SegSize},
                    {1 * SegSize,SegSize},
                    {0 * SegSize,SegSize}]),
    true = verify_bin(B5a, 0 * SegCnt, SegCnt),
    true = verify_bin(B5b, 1 * SegCnt, SegCnt),
    true = verify_bin(B5c, 2 * SegCnt, SegCnt),
    true = verify_bin(B5d, 3 * SegCnt, SegCnt),
    {ok,[B5g,B5f,B5e]} =
        file:pread(FD5,
                   [{3 * SegSize,2 * SegSize},
                    {1 * SegSize,2 * SegSize},
                    {0 * SegSize,1 * SegSize}]),
    true = verify_bin(B5e, 0 * SegCnt, 1 * SegCnt),
    true = verify_bin(B5f, 1 * SegCnt, 2 * SegCnt),
    true = verify_bin(B5g, 3 * SegCnt, 1 * SegCnt),
    {ok,[B5i,B5h]} =
        file:pread(FD5,
                   [{2 * SegSize,3 * SegSize},{0 * SegSize,2 * SegSize}]),
    true = verify_bin(B5h, 0 * SegCnt, 2 * SegCnt),
    true = verify_bin(B5i, 2 * SegCnt, 2 * SegCnt),
    {ok,[B5l,B5k,B5j]} =
        file:pread(FD5,
                   [{3 * SegSize,1 * SegSize},
                    {2 * SegSize,1 * SegSize},
                    {0 * SegSize,2 * SegSize}]),
    true = verify_bin(B5j, 0 * SegCnt, 2 * SegCnt),
    true = verify_bin(B5k, 2 * SegCnt, 1 * SegCnt),
    true = verify_bin(B5l, 3 * SegCnt, 1 * SegCnt),
    Req =
        lists:flatten(lists:duplicate(17,
                                      [{2 * SegSize,2 * SegSize},
                                       {0 * SegSize,2 * SegSize}])),
    {{ok,_},Comment} = response_analysis(file, pread, [FD5,Req]),
    ok = file:close(FD5),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    {comment,Comment}.

segment_write(suite) ->
    [];
segment_write(doc) ->
    ["Tests the segmenting of large writes"];
segment_write(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(60)),
    Name =
        filename:join(test_server:lookup_config(priv_dir, Config),
                      "file_SUITE" ++ "_segment_write"),
    SegSize = 256 * 1024,
    SegCnt = SegSize div 4,
    Cnt = 4 * SegCnt,
    Bin = create_bin(0, Cnt),
    {ok,FD1} = file:open(Name, [write,raw,binary]),
    ok = file:write(FD1, subbin(Bin, 0 * SegSize, 1 * SegSize)),
    ok = file:write(FD1, subbin(Bin, 1 * SegSize, 1 * SegSize)),
    ok = file:write(FD1, subbin(Bin, 2 * SegSize, 1 * SegSize)),
    ok = file:write(FD1, subbin(Bin, 3 * SegSize, 1 * SegSize)),
    ok = file:close(FD1),
    true = verify_file(Name, Cnt),
    {ok,FD2} = file:open(Name, [write,raw,binary]),
    ok = file:write(FD2, subbin(Bin, 0 * SegSize, 1 * SegSize)),
    ok = file:write(FD2, subbin(Bin, 1 * SegSize, 2 * SegSize)),
    ok = file:write(FD2, subbin(Bin, 3 * SegSize, 1 * SegSize)),
    ok = file:close(FD2),
    true = verify_file(Name, Cnt),
    ok =
        write_file(Name,
                   [subbin(Bin, 0 * SegSize, 1 * SegSize),
                    subbin(Bin, 1 * SegSize, 1 * SegSize),
                    subbin(Bin, 2 * SegSize, 1 * SegSize),
                    subbin(Bin, 3 * SegSize, 1 * SegSize)]),
    true = verify_file(Name, Cnt),
    ok =
        write_file(Name,
                   [subbin(Bin, 0 * SegSize, 1 * SegSize),
                    subbin(Bin, 1 * SegSize, 2 * SegSize),
                    subbin(Bin, 3 * SegSize, 1 * SegSize)]),
    true = verify_file(Name, Cnt),
    ok =
        write_file(Name,
                   [subbin(Bin, 0 * SegSize, 2 * SegSize),
                    subbin(Bin, 2 * SegSize, 2 * SegSize)]),
    true = verify_file(Name, Cnt),
    ok =
        write_file(Name,
                   [subbin(Bin, 0 * SegSize, 2 * SegSize),
                    subbin(Bin, 2 * SegSize, 1 * SegSize),
                    subbin(Bin, 3 * SegSize, 1 * SegSize)]),
    true = verify_file(Name, Cnt),
    {ok,FD3} = file:open(Name, [write,raw,binary]),
    ok =
        file:pwrite(FD3,
                    3 * SegSize,
                    subbin(Bin, 3 * SegSize, 1 * SegSize)),
    ok =
        file:pwrite(FD3,
                    2 * SegSize,
                    subbin(Bin, 2 * SegSize, 1 * SegSize)),
    ok =
        file:pwrite(FD3,
                    1 * SegSize,
                    subbin(Bin, 1 * SegSize, 1 * SegSize)),
    ok =
        file:pwrite(FD3,
                    0 * SegSize,
                    subbin(Bin, 0 * SegSize, 1 * SegSize)),
    ok = file:close(FD3),
    true = verify_file(Name, Cnt),
    {ok,FD4} = file:open(Name, [write,raw,binary]),
    ok =
        file:pwrite(FD4,
                    3 * SegSize,
                    subbin(Bin, 3 * SegSize, 1 * SegSize)),
    ok =
        file:pwrite(FD4,
                    1 * SegSize,
                    subbin(Bin, 1 * SegSize, 2 * SegSize)),
    ok =
        file:pwrite(FD4,
                    0 * SegSize,
                    subbin(Bin, 0 * SegSize, 1 * SegSize)),
    ok = file:close(FD4),
    true = verify_file(Name, Cnt),
    {ok,FD5} = file:open(Name, [write,raw,binary]),
    ok =
        file:pwrite(FD5,
                    [{3 * SegSize,subbin(Bin, 3 * SegSize, 1 * SegSize)}]),
    ok =
        file:pwrite(FD5,
                    [{2 * SegSize,subbin(Bin, 2 * SegSize, 1 * SegSize)}]),
    ok =
        file:pwrite(FD5,
                    [{1 * SegSize,subbin(Bin, 1 * SegSize, 1 * SegSize)}]),
    ok =
        file:pwrite(FD5,
                    [{0 * SegSize,subbin(Bin, 0 * SegSize, 1 * SegSize)}]),
    ok = file:close(FD5),
    true = verify_file(Name, Cnt),
    {ok,FD6} = file:open(Name, [write,raw,binary]),
    ok =
        file:pwrite(FD6,
                    [{3 * SegSize,subbin(Bin, 3 * SegSize, 1 * SegSize)}]),
    ok =
        file:pwrite(FD6,
                    [{1 * SegSize,subbin(Bin, 1 * SegSize, 2 * SegSize)}]),
    ok =
        file:pwrite(FD6,
                    [{0 * SegSize,subbin(Bin, 0 * SegSize, 1 * SegSize)}]),
    ok = file:close(FD6),
    true = verify_file(Name, Cnt),
    ok =
        pwrite_file(Name,
                    [{3 * SegSize,subbin(Bin, 3 * SegSize, 1 * SegSize)},
                     {2 * SegSize,subbin(Bin, 2 * SegSize, 1 * SegSize)},
                     {1 * SegSize,subbin(Bin, 1 * SegSize, 1 * SegSize)},
                     {0 * SegSize,subbin(Bin, 0 * SegSize, 1 * SegSize)}]),
    true = verify_file(Name, Cnt),
    ok =
        pwrite_file(Name,
                    [{3 * SegSize,subbin(Bin, 3 * SegSize, 1 * SegSize)},
                     {1 * SegSize,subbin(Bin, 1 * SegSize, 2 * SegSize)},
                     {0 * SegSize,subbin(Bin, 0 * SegSize, 1 * SegSize)}]),
    true = verify_file(Name, Cnt),
    ok =
        pwrite_file(Name,
                    [{2 * SegSize,subbin(Bin, 2 * SegSize, 2 * SegSize)},
                     {0 * SegSize,subbin(Bin, 0 * SegSize, 2 * SegSize)}]),
    true = verify_file(Name, Cnt),
    ok =
        pwrite_file(Name,
                    [{3 * SegSize,subbin(Bin, 3 * SegSize, 1 * SegSize)},
                     {2 * SegSize,subbin(Bin, 2 * SegSize, 1 * SegSize)},
                     {0 * SegSize,subbin(Bin, 0 * SegSize, 2 * SegSize)}]),
    true = verify_file(Name, Cnt),
    {ok,FD7} = file:open(Name, [write,raw,binary]),
    Req =
        lists:flatten(lists:duplicate(17,
                                      [{2 * SegSize,
                                        subbin(Bin,
                                               2 * SegSize,
                                               2 * SegSize)},
                                       {0 * SegSize,
                                        subbin(Bin,
                                               0 * SegSize,
                                               2 * SegSize)}])),
    {ok,Comment} = response_analysis(file, pwrite, [FD7,Req]),
    ok = file:close(FD7),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    {comment,Comment}.

ipread(suite) ->
    [];
ipread(doc) ->
    ["Test Dets special indirect pread"];
ipread(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(30)),
    Dir = test_server:lookup_config(priv_dir, Config),
    ok = ipread_int(Dir, [raw,binary]),
    ok = ipread_int(Dir, [raw]),
    ok = ipread_int(Dir, [binary]),
    ok = ipread_int(Dir, []),
    ok = ipread_int(Dir, [ram,binary]),
    ok = ipread_int(Dir, [ram]),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

ipread_int(Dir, ModeList) ->
    Name =
        filename:join(Dir,
                      lists:flatten(["file_SUITE",
                                     "_ipread",
                                     lists:map(fun(X) ->
                                                      ["_",
                                                       atom_to_list(X)]
                                               end,
                                               ModeList)])),
    io:format("ipread_int<~p, ~p>~n", [Name,ModeList]),
    {Conv,Sizeof} =
        case lists:member(binary, ModeList) of
            true ->
                {fun(Bin) when is_binary(Bin) ->
                        Bin;
                    (List) when is_list(List) ->
                        list_to_binary(List)
                 end,
                 fun erlang:byte_size/1};
            false ->
                {fun(Bin) when is_binary(Bin) ->
                        binary_to_list(Bin);
                    (List) when is_list(List) ->
                        List
                 end,
                 fun erlang:length/1}
        end,
    Pos = 4711,
    Data = Conv("THE QUICK BROWN FOX JUMPS OVER A LAZY DOG"),
    Size = Sizeof(Data),
    Init = Conv("                 "),
    SizeInit = Sizeof(Init),
    Head = Conv(<<Size:32/big-unsigned,Pos:32/big-unsigned>>),
    Filler = Conv(bytes($\s, Pos - SizeInit - Sizeof(Head))),
    Size1 = Size + 1,
    SizePos = Size + Pos,
    {ok,FD} = file:open(Name, [write,read|ModeList]),
    ok = file:truncate(FD),
    ok = file:write(FD, Init),
    ok = file:write(FD, Head),
    ok = file:write(FD, Filler),
    ok = file:write(FD, Data),
    {ok,{Size,Pos,Data}} =
        file:ipread_s32bu_p32bu(FD, SizeInit, infinity),
    eof = file:ipread_s32bu_p32bu(FD, SizeInit, Size - 1),
    ok =
        file:pwrite(FD,
                    SizeInit,
                    <<Size1:32/big-unsigned,Pos:32/big-unsigned>>),
    {ok,{Size1,Pos,Data}} = file:ipread_s32bu_p32bu(FD, SizeInit, Size1),
    ok =
        file:pwrite(FD,
                    SizeInit,
                    <<Size:32/big-unsigned,SizePos:32/big-unsigned>>),
    {ok,{Size,SizePos,eof}} =
        file:ipread_s32bu_p32bu(FD, SizeInit, Size),
    ok =
        file:pwrite(FD,
                    SizeInit,
                    <<0:32/big-unsigned,Pos:32/big-unsigned>>),
    {ok,{0,Pos,eof}} = file:ipread_s32bu_p32bu(FD, SizeInit, Size),
    eof =
        file:ipread_s32bu_p32bu(FD,
                                Pos + Size - (Sizeof(Head) - 1),
                                infinity),
    eof = file:ipread_s32bu_p32bu(FD, Pos + Size, infinity),
    ok = file:close(FD),
    ok.

interleaved_read_write(suite) ->
    [];
interleaved_read_write(doc) ->
    ["Tests interleaved read and writes"];
interleaved_read_write(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(30)),
    Dir = test_server:lookup_config(priv_dir, Config),
    File =
        filename:join(Dir, "file_SUITE" ++ "interleaved_read_write.txt"),
    {ok,F1} = file:open(File, [write]),
    ok = file:write(F1, "data---r1."),
    ok = file:write(F1, "data---r2."),
    ok = file:write(F1, "data---r3."),
    ok = file:close(F1),
    {ok,F2} = file:open(File, [read,write]),
    {ok,"data---r1."} = file:read(F2, 10),
    ok = file:write(F2, "data---w2."),
    ok = file:close(F2),
    {ok,F3} = file:open(File, [read]),
    {ok,"data---r1."} = file:read(F3, 10),
    {ok,"data---w2."} = file:read(F3, 10),
    {ok,"data---r3."} = file:read(F3, 10),
    eof = file:read(F3, 1),
    ok = file:close(F2),
    [] = flush(),
    test_server:timetrap_cancel(Dog),
    ok.

otp_5814(suite) ->
    [];
otp_5814(doc) ->
    ["OTP-5814. eval/consult/script return correct line numbers"];
otp_5814(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(10)),
    PrivDir = test_server:lookup_config(priv_dir, Config),
    File = filename:join(PrivDir, "otp_5814"),
    Path = [PrivDir],
    ok =
        file:write_file(File,
                        <<"{a,b,c}.\n                                  "
                          "      a.\n                                  "
                          "      b.\n                                  "
                          "      c.\n                                  "
                          "      {d,e,\n                               "
                          "         [}.">>),
    {error,{6,erl_parse,_}} = file:eval(File),
    {error,{6,erl_parse,_}} = file:consult(File),
    {error,{6,erl_parse,_}} = file:path_consult(Path, File),
    {error,{6,erl_parse,_}} = file:path_eval(Path, File),
    {error,{6,erl_parse,_}} = file:script(File),
    {error,{6,erl_parse,_}} = file:path_script(Path, File),
    ok = file:write_file(File, <<>>),
    {error,{1,file,undefined_script}} = file:path_script(Path, File),
    ok =
        file:write_file(File,
                        <<"a.\n                                        "
                          "b.\n                                        "
                          "1/0.">>),
    {error,{3,file,{error,badarith,_}}} = file:eval(File),
    ok = file:write_file(File, <<"erlang:raise(throw, apa, []).">>),
    {error,{1,file,{throw,apa,_}}} = file:eval(File),
    file:delete(File),
    test_server:timetrap_cancel(Dog),
    ok.

otp_10852(suite) ->
    [];
otp_10852(doc) ->
    ["OTP-10852. +fnu and latin1 filenames"];
otp_10852(Config) when is_list(Config) ->
    Node = start_node(erl_pp_helper, "+fnu"),
    Dir = test_server:lookup_config(priv_dir, Config),
    B = filename:join(Dir, <<"">>),
    ok = rpc_call(Node, get_cwd, [B]),
    {error,no_translation} = rpc_call(Node, set_cwd, [B]),
    ok = rpc_call(Node, delete, [B]),
    ok = rpc_call(Node, rename, [B,B]),
    ok = rpc_call(Node, read_file_info, [B]),
    ok = rpc_call(Node, read_link_info, [B]),
    ok = rpc_call(Node, read_link, [B]),
    ok = rpc_call(Node, write_file_info, [B,#file_info{}]),
    ok = rpc_call(Node, list_dir, [B]),
    ok = rpc_call(Node, list_dir_all, [B]),
    ok = rpc_call(Node, read_file, [B]),
    ok = rpc_call(Node, make_link, [B,B]),
    ok = rpc_call(Node, make_symlink, [B,B]),
    ok = rpc_call(Node, delete, [B]),
    ok = rpc_call(Node, make_dir, [B]),
    ok = rpc_call(Node, del_dir, [B]),
    ok = rpc_call(Node, write_file, [B,B]),
    {ok,Fd} = rpc_call(Node, open, [B,[read]]),
    ok = rpc_call(Node, close, [Fd]),
    {ok,0} = rpc_call(Node, copy, [B,B]),
    {ok,Fd2,B} = rpc_call(Node, path_open, [["."],B,[read]]),
    ok = rpc_call(Node, close, [Fd2]),
    true = test_server:stop_node(Node),
    ok.

rpc_call(N, F, As) ->
    case rpc:call(N, file, F, As) of
        {error,enotsup} ->
            ok;
        {error,enoent} ->
            ok;
        {error,badarg} ->
            ok;
        Else ->
            Else
    end.

large_file(suite) ->
    [];
large_file(doc) ->
    ["Tests positioning in large files (> 4G)"];
large_file(Config) when is_list(Config) ->
    run_large_file_test(Config,
                        fun(Name) ->
                               do_large_file(Name)
                        end,
                        "_large_file").

do_large_file(Name) ->
    Watchdog = test_server:timetrap(test_server:minutes(20)),
    S = "1234567890",
    L = length(S),
    R = lists:reverse(S),
    P = 1 bsl 32,
    Ss = lists:sort(S),
    Rs = lists:reverse(Ss),
    {ok,F} = file:open(Name, [raw,read,write]),
    ok = file:write(F, S),
    {ok,P} = file:position(F, P),
    ok = file:write(F, R),
    {ok,0} = file:position(F, bof),
    {ok,S} = file:read(F, L),
    {ok,P} = file:position(F, {eof,- L}),
    {ok,R} = file:read(F, L + 1),
    {ok,S} = file:pread(F, 0, L),
    {ok,R} = file:pread(F, P, L + 1),
    ok = file:pwrite(F, 0, Ss),
    ok = file:pwrite(F, P, Rs),
    {ok,0} = file:position(F, bof),
    {ok,Ss} = file:read(F, L),
    {ok,P} = file:position(F, {eof,- L}),
    {ok,Rs} = file:read(F, L + 1),
    ok = file:close(F),
    PL = P + L,
    PLL = PL + L,
    {ok,F1} = file:open(Name, [raw,read,write,append]),
    ok = file:write(F1, R),
    {ok,PLL} = file:position(F1, {cur,0}),
    {ok,Rs} = file:pread(F1, P, L),
    {ok,PL} = file:position(F1, {eof,- L}),
    {ok,R} = file:read(F1, L + 1),
    ok = file:close(F1),
    test_server:timetrap_cancel(Watchdog),
    ok.

large_write(Config) when is_list(Config) ->
    run_large_file_test(Config,
                        fun(Name) ->
                               do_large_write(Name)
                        end,
                        "_large_write").

do_large_write(Name) ->
    Memsize = memsize(),
    io:format("Memsize = ~w Bytes~n", [Memsize]),
    case {erlang:system_info(wordsize),Memsize} of
        {4,_} ->
            {skip,"Needs a 64-bit emulator"};
        {8,N} when N < 6 bsl 30 ->
            {skip,
             "This machine has < 6 GB  memory: " ++ integer_to_list(N)};
        {8,_} ->
            Size = 4 * 1024 * 1024 * 1024 + 1,
            Bin = <<0:Size/unit:8>>,
            ok = file:write_file(Name, Bin),
            {ok,#file_info{size = Size}} = file:read_file_info(Name),
            ok
    end.

response_analysis(Module, Function, Arguments) ->
    Parent = self(),
    erlang:yield(),
    Child =
        spawn_link(fun() ->
                          receive
                              {Parent,start,Ts} ->
                                  ok
                          end,
                          Stat =
                              iterate(response_stat(response_stat(init,
                                                                  Ts),
                                                    now()),
                                      done,
                                      fun(S) ->
                                             erlang:yield(),
                                             receive
                                                 {Parent,stop} ->
                                                     done
                                             after
                                                 0 ->
                                                     response_stat(S,
                                                                   now())
                                             end
                                      end),
                          Parent
                          !
                          {self(),stopped,response_stat(Stat, now())}
                   end),
    Child ! {Parent,start,now()},
    Result = apply(Module, Function, Arguments),
    Child ! {Parent,stop},
    {N,Sum,_,M,Max} =
        receive
            {Child,stopped,X} ->
                X
        end,
    Mean_ms = 0.001 * Sum / (N - 1),
    Max_ms = 0.001 * Max,
    Comment =
        lists:flatten(io_lib:format("Scheduling interval: Mean = ~.3f m"
                                    "s, "
                                    ++
                                    "Max = ~.3f ms for no ~p of ~p.~n",
                                    [Mean_ms,Max_ms,M,N - 1])),
    {Result,Comment}.

response_stat(init, Ts) ->
    {0,0,Ts,0,0};
response_stat({N,Sum,{A1,B1,C1},M,Max}, {A2,B2,C2} = Ts) ->
    D = C2 - C1 + 1000000 * (B2 - B1 + 1000000 * (A2 - A1)),
    if
        D > Max ->
            {N + 1,Sum + D,Ts,N,D};
        true ->
            {N + 1,Sum + D,Ts,M,Max}
    end.

create_file_slow(Name, N) when is_integer(N), N >= 0 ->
    {ok,FD} = file:open(Name, [raw,write,delayed_write,binary]),
    ok = create_file_slow(FD, 0, N),
    ok = file:close(FD),
    ok.

create_file_slow(_FD, M, M) ->
    ok;
create_file_slow(FD, M, N) ->
    ok = file:write(FD, <<M:32/unsigned>>),
    create_file_slow(FD, M + 1, N).

create_file(Name, N) when is_integer(N), N >= 0 ->
    {ok,FD} = file:open(Name, [raw,write,delayed_write,binary]),
    ok = create_file(FD, 0, N),
    ok = file:close(FD),
    ok.

create_file(_FD, M, M) ->
    ok;
create_file(FD, M, N) when M + 1024 =< N ->
    create_file(FD, M, M + 1024, []),
    create_file(FD, M + 1024, N);
create_file(FD, M, N) ->
    create_file(FD, M, N, []).

create_file(FD, M, M, R) ->
    ok = file:write(FD, R);
create_file(FD, M, N0, R) when M + 8 =< N0 ->
    N1 = N0 - 1,
    N2 = N0 - 2,
    N3 = N0 - 3,
    N4 = N0 - 4,
    N5 = N0 - 5,
    N6 = N0 - 6,
    N7 = N0 - 7,
    N8 = N0 - 8,
    create_file(FD,
                M,
                N8,
                [<<N8:32/unsigned,
                   N7:32/unsigned,
                   N6:32/unsigned,
                   N5:32/unsigned,
                   N4:32/unsigned,
                   N3:32/unsigned,
                   N2:32/unsigned,
                   N1:32/unsigned>>|
                 R]);
create_file(FD, M, N0, R) ->
    N1 = N0 - 1,
    create_file(FD, M, N1, [<<N1:32/unsigned>>|R]).

create_bin(M, N) when is_integer(M), is_integer(N), N >= 0, M >= 0 ->
    create_bin(M, M + N, []).

create_bin(N, N, R) ->
    list_to_binary(R);
create_bin(M, N0, R) when M + 8 =< N0 ->
    N1 = N0 - 1,
    N2 = N0 - 2,
    N3 = N0 - 3,
    N4 = N0 - 4,
    N5 = N0 - 5,
    N6 = N0 - 6,
    N7 = N0 - 7,
    N8 = N0 - 8,
    create_bin(M,
               N8,
               [<<N8:32/unsigned,
                  N7:32/unsigned,
                  N6:32/unsigned,
                  N5:32/unsigned,
                  N4:32/unsigned,
                  N3:32/unsigned,
                  N2:32/unsigned,
                  N1:32/unsigned>>|
                R]);
create_bin(M, N0, R) ->
    N1 = N0 - 1,
    create_bin(M, N1, [<<N1:32/unsigned>>|R]).

verify_bin(<<>>, _, 0) ->
    true;
verify_bin(<<>>, _, _) ->
    false;
verify_bin(Bin, N, Cnt) ->
    N0 = N + 0,
    N1 = N + 1,
    N2 = N + 2,
    N3 = N + 3,
    N4 = N + 4,
    N5 = N + 5,
    N6 = N + 6,
    N7 = N + 7,
    case Bin of
        <<N0:32/unsigned,
          N1:32/unsigned,
          N2:32/unsigned,
          N3:32/unsigned,
          N4:32/unsigned,
          N5:32/unsigned,
          N6:32/unsigned,
          N7:32/unsigned,
          B/binary>> ->
            verify_bin(B, N + 8, Cnt - 8);
        <<N:32/unsigned,B/binary>> ->
            verify_bin(B, N + 1, Cnt - 1);
        _ ->
            false
    end.

verify_file(Name, N) when is_integer(N), N >= 0 ->
    case file:open(Name, [raw,read,binary]) of
        {ok,FD} ->
            Result = verify_file(FD, 0, 64 * 1024, N),
            ok = file:close(FD),
            Result;
        Error ->
            Error
    end.

verify_file(FD, N, _, N) ->
    case file:read(FD, 1) of
        eof ->
            true;
        {ok,_} ->
            false
    end;
verify_file(FD, M, Cnt, N) when M + Cnt =< N ->
    case file:read(FD, 4 * Cnt) of
        {ok,Bin} ->
            case verify_bin(Bin, M, Cnt) of
                true ->
                    verify_file(FD, M + Cnt, Cnt, N);
                false ->
                    false
            end;
        _ ->
            false
    end;
verify_file(FD, M, _Cnt, N) ->
    verify_file(FD, M, N - M, N).

subbin(Bin, M, N) ->
    <<_:M/binary,B:N/binary,_/binary>> = Bin,
    B.

write_file(Name, Data) ->
    case file:open(Name, [raw,write,binary]) of
        {ok,FD} ->
            Result = file:write(FD, Data),
            case {Result,file:close(FD)} of
                {ok,R} ->
                    R;
                _ ->
                    Result
            end;
        Error ->
            Error
    end.

pwrite_file(Name, Data) ->
    case file:open(Name, [raw,write,binary]) of
        {ok,FD} ->
            Result = file:pwrite(FD, Data),
            case {Result,file:close(FD)} of
                {ok,R} ->
                    R;
                _ ->
                    Result
            end;
        Error ->
            Error
    end.

read_line_testdata(PrivDir) ->
    All0 =
        [{fun read_line_create0/1,"Testdata1.txt",5,10},
         {fun read_line_create1/1,"Testdata2.txt",401,802},
         {fun read_line_create2/1,"Testdata3.txt",1,2},
         {fun read_line_create3/1,"Testdata4.txt",601,fail},
         {fun read_line_create4/1,"Testdata5.txt",601,1002},
         {fun read_line_create5/1,"Testdata6.txt",601,1202},
         {fun read_line_create6/1,"Testdata7.txt",601,1202},
         {fun read_line_create7/1,"Testdata8.txt",4001,8002}],
    [ 
     {A,filename:join([PrivDir,B]),C,D} ||
         {A,B,C,D} <- All0
    ].

read_line_create_files(TestData) ->
    [ 
     Function(File) ||
         {Function,File,_,_} <- TestData
    ].

read_line_remove_files(TestData) ->
    [ 
     file:delete(File) ||
         {_Function,File,_,_} <- TestData
    ].

read_line_1(suite) ->
    [];
read_line_1(doc) ->
    ["read_line with prim_file"];
read_line_1(Config) when is_list(Config) ->
    PrivDir = test_server:lookup_config(priv_dir, Config),
    All = read_line_testdata(PrivDir),
    read_line_create_files(All),
    [ 
     begin
         io:format("read_line_all: ~s~n", [File]),
         {X,_} = read_line_all(File),
         true
     end ||
         {_,File,X,_} <- All
    ],
    [ 
     begin
         io:format("read_line_all_alternating: ~s~n", [File]),
         {Y,_} = read_line_all_alternating(File),
         true
     end ||
         {_,File,_,Y} <- All,
         Y =/= fail
    ],
    [ 
     begin
         io:format("read_line_all_alternating (failing as should): ~s~n",
                   [File]),
         {'EXIT',_} = (catch read_line_all_alternating(File)),
         true
     end ||
         {_,File,_,Y} <- All,
         Y =:= fail
    ],
    read_line_remove_files(All),
    ok.

read_line_2(suite) ->
    [];
read_line_2(doc) ->
    ["read_line with file"];
read_line_2(Config) when is_list(Config) ->
    PrivDir = test_server:lookup_config(priv_dir, Config),
    All = read_line_testdata(PrivDir),
    read_line_create_files(All),
    [ 
     begin
         io:format("read_line_all: ~s~n", [File]),
         {X,_} = read_line_all2(File),
         true
     end ||
         {_,File,X,_} <- All
    ],
    [ 
     begin
         io:format("read_line_all_alternating: ~s~n", [File]),
         {Y,_} = read_line_all_alternating2(File),
         true
     end ||
         {_,File,_,Y} <- All,
         Y =/= fail
    ],
    [ 
     begin
         io:format("read_line_all_alternating (failing as should): ~s~n",
                   [File]),
         {'EXIT',_} = (catch read_line_all_alternating2(File)),
         true
     end ||
         {_,File,_,Y} <- All,
         Y =:= fail
    ],
    read_line_remove_files(All),
    ok.

read_line_3(suite) ->
    [];
read_line_3(doc) ->
    ["read_line with raw file"];
read_line_3(Config) when is_list(Config) ->
    PrivDir = test_server:lookup_config(priv_dir, Config),
    All = read_line_testdata(PrivDir),
    read_line_create_files(All),
    [ 
     begin
         io:format("read_line_all: ~s~n", [File]),
         {X,_} = read_line_all3(File),
         true
     end ||
         {_,File,X,_} <- All
    ],
    [ 
     begin
         io:format("read_line_all_alternating: ~s~n", [File]),
         {Y,_} = read_line_all_alternating3(File),
         true
     end ||
         {_,File,_,Y} <- All,
         Y =/= fail
    ],
    [ 
     begin
         io:format("read_line_all_alternating (failing as should): ~s~n",
                   [File]),
         {'EXIT',_} = (catch read_line_all_alternating3(File)),
         true
     end ||
         {_,File,_,Y} <- All,
         Y =:= fail
    ],
    read_line_remove_files(All),
    ok.

read_line_4(suite) ->
    [];
read_line_4(doc) ->
    ["read_line with raw buffered file"];
read_line_4(Config) when is_list(Config) ->
    PrivDir = test_server:lookup_config(priv_dir, Config),
    All = read_line_testdata(PrivDir),
    read_line_create_files(All),
    [ 
     begin
         io:format("read_line_all: ~s~n", [File]),
         {X,_} = read_line_all4(File),
         true
     end ||
         {_,File,X,_} <- All
    ],
    [ 
     begin
         io:format("read_line_all_alternating: ~s~n", [File]),
         {Y,_} = read_line_all_alternating4(File),
         true
     end ||
         {_,File,_,Y} <- All,
         Y =/= fail
    ],
    [ 
     begin
         io:format("read_line_all_alternating (failing as should): ~s~n",
                   [File]),
         {'EXIT',_} = (catch read_line_all_alternating4(File)),
         true
     end ||
         {_,File,_,Y} <- All,
         Y =:= fail
    ],
    read_line_remove_files(All),
    ok.

rl_lines() ->
    [<<"hej">>,<<"hopp">>,<<"i">>,<<"lingon\rskogen">>].

read_line_create0(Filename) ->
    {ok,F} = file:open(Filename, [write]),
    L = rl_lines(),
    [ 
     file:write(F, [R,<<"\r\n">>]) ||
         R <- L
    ],
    file:write(F, <<"Inget radslut\r">>),
    file:close(F).

read_line_create1(Filename) ->
    {ok,F} = file:open(Filename, [write]),
    L = rl_lines(),
    [ 
     begin
         [ 
          file:write(F, [R,<<"\r\n">>]) ||
              R <- L
         ],
         file:write(F, <<"Inget radslut\r">>)
     end ||
         _ <- lists:seq(1, 100)
    ],
    file:close(F).

read_line_create2(Filename) ->
    {ok,F} = file:open(Filename, [write]),
    L = rl_lines(),
    [ 
     begin
         [ 
          file:write(F, [R]) ||
              R <- L
         ],
         file:write(F, <<"Inget radslut\r">>)
     end ||
         _ <- lists:seq(1, 200)
    ],
    file:write(F, <<"\r\n">>),
    file:close(F).

read_line_create3(Filename) ->
    {ok,F} = file:open(Filename, [write]),
    L = rl_lines(),
    [ 
     begin
         file:write(F, <<"\r\n">>),
         file:write(F, <<"\r\n">>),
         [ 
          file:write(F, [R,<<"\r\n">>]) ||
              R <- L
         ],
         file:write(F, <<"Inget radslut\r">>)
     end ||
         _ <- lists:seq(1, 100)
    ],
    file:close(F).

read_line_create4(Filename) ->
    {ok,F} = file:open(Filename, [write]),
    L = rl_lines(),
    [ 
     begin
         file:write(F, <<"\n">>),
         file:write(F, <<"\n">>),
         [ 
          file:write(F, [R,<<"\r\n">>]) ||
              R <- L
         ],
         file:write(F, <<"Inget radslut\r">>)
     end ||
         _ <- lists:seq(1, 100)
    ],
    file:close(F).

read_line_create5(Filename) ->
    {ok,F} = file:open(Filename, [write]),
    L = rl_lines(),
    [ 
     begin
         file:write(F, <<"i\n">>),
         file:write(F, <<"i\n">>),
         [ 
          file:write(F, [R,<<"\r\n">>]) ||
              R <- L
         ],
         file:write(F, <<"Inget radslut\r">>)
     end ||
         _ <- lists:seq(1, 100)
    ],
    file:close(F).

read_line_create6(Filename) ->
    {ok,F} = file:open(Filename, [write]),
    L = rl_lines(),
    [ 
     begin
         file:write(F, <<"i\r\n">>),
         file:write(F, <<"i\r\n">>),
         [ 
          file:write(F, [R,<<"\r\n">>]) ||
              R <- L
         ],
         file:write(F, <<"Inget radslut\r">>)
     end ||
         _ <- lists:seq(1, 100)
    ],
    file:close(F).

read_line_create7(Filename) ->
    {ok,F} = file:open(Filename, [write]),
    L = rl_lines(),
    [ 
     begin
         [ 
          file:write(F, [R,<<"\r\n">>]) ||
              R <- L
         ],
         file:write(F, <<"Inget radslut\r">>)
     end ||
         _ <- lists:seq(1, 1000)
    ],
    file:close(F).

read_line_all(Filename) ->
    {ok,F} = prim_file:open(Filename, [read,binary]),
    X = read_rl_lines(F),
    prim_file:close(F),
    Bin =
        list_to_binary([ 
                        B ||
                            {ok,B} <- X
                       ]),
    Bin =
        re:replace(list_to_binary([element(2, file:read_file(Filename))]),
                   "\r\n",
                   "\n",
                   [global,{return,binary}]),
    {length(X),Bin}.

read_line_all2(Filename) ->
    {ok,F} = file:open(Filename, [read,binary]),
    X = read_rl_lines2(F),
    file:close(F),
    Bin =
        list_to_binary([ 
                        B ||
                            {ok,B} <- X
                       ]),
    Bin =
        re:replace(list_to_binary([element(2, file:read_file(Filename))]),
                   "\r\n",
                   "\n",
                   [global,{return,binary}]),
    {length(X),Bin}.

read_line_all3(Filename) ->
    {ok,F} = file:open(Filename, [read,binary,raw]),
    X = read_rl_lines2(F),
    file:close(F),
    Bin =
        list_to_binary([ 
                        B ||
                            {ok,B} <- X
                       ]),
    Bin =
        re:replace(list_to_binary([element(2, file:read_file(Filename))]),
                   "\r\n",
                   "\n",
                   [global,{return,binary}]),
    {length(X),Bin}.

read_line_all4(Filename) ->
    {ok,F} = file:open(Filename, [read,binary,raw,{read_ahead,8192}]),
    X = read_rl_lines2(F),
    file:close(F),
    Bin =
        list_to_binary([ 
                        B ||
                            {ok,B} <- X
                       ]),
    Bin =
        re:replace(list_to_binary([element(2, file:read_file(Filename))]),
                   "\r\n",
                   "\n",
                   [global,{return,binary}]),
    {length(X),Bin}.

read_rl_lines(F) ->
    case prim_file:read_line(F) of
        eof ->
            [];
        {error,X} ->
            {error,X};
        List ->
            [List|read_rl_lines(F)]
    end.

read_rl_lines2(F) ->
    case file:read_line(F) of
        eof ->
            [];
        {error,X} ->
            {error,X};
        List ->
            [List|read_rl_lines2(F)]
    end.

read_line_all_alternating(Filename) ->
    {ok,F} = prim_file:open(Filename, [read,binary]),
    X = read_rl_lines(F, true),
    prim_file:close(F),
    Bin =
        list_to_binary([ 
                        B ||
                            {ok,B} <- X
                       ]),
    Bin =
        re:replace(list_to_binary([element(2, file:read_file(Filename))]),
                   "\r\n",
                   "\n",
                   [global,{return,binary}]),
    {length(X),Bin}.

read_line_all_alternating2(Filename) ->
    {ok,F} = file:open(Filename, [read,binary]),
    X = read_rl_lines2(F, true),
    file:close(F),
    Bin =
        list_to_binary([ 
                        B ||
                            {ok,B} <- X
                       ]),
    Bin =
        re:replace(list_to_binary([element(2, file:read_file(Filename))]),
                   "\r\n",
                   "\n",
                   [global,{return,binary}]),
    {length(X),Bin}.

read_line_all_alternating3(Filename) ->
    {ok,F} = file:open(Filename, [read,binary,raw]),
    X = read_rl_lines2(F, true),
    file:close(F),
    Bin =
        list_to_binary([ 
                        B ||
                            {ok,B} <- X
                       ]),
    Bin =
        re:replace(list_to_binary([element(2, file:read_file(Filename))]),
                   "\r\n",
                   "\n",
                   [global,{return,binary}]),
    {length(X),Bin}.

read_line_all_alternating4(Filename) ->
    {ok,F} = file:open(Filename, [read,binary,raw,{read_ahead,8192}]),
    X = read_rl_lines2(F, true),
    file:close(F),
    Bin =
        list_to_binary([ 
                        B ||
                            {ok,B} <- X
                       ]),
    Bin =
        re:replace(list_to_binary([element(2, file:read_file(Filename))]),
                   "\r\n",
                   "\n",
                   [global,{return,binary}]),
    {length(X),Bin}.

read_rl_lines(F, Alternate) ->
    case
        begin
            case Alternate of
                true ->
                    prim_file:read(F, 1);
                false ->
                    prim_file:read_line(F)
            end
        end
    of
        eof ->
            [];
        {error,X} ->
            {error,X};
        List ->
            [List|read_rl_lines(F, not Alternate)]
    end.

read_rl_lines2(F, Alternate) ->
    case
        begin
            case Alternate of
                true ->
                    file:read(F, 1);
                false ->
                    file:read_line(F)
            end
        end
    of
        eof ->
            [];
        {error,X} ->
            {error,X};
        List ->
            [List|read_rl_lines2(F, not Alternate)]
    end.

bytes(B, N)
    when
        is_integer(B),
        0 =< B,
        B =< 255,
        is_integer(N),
        N > 2,
        N band 1 == 0 ->
    [bytes(B, N bsr 1),bytes(B, N bsr 1)];
bytes(B, 0) when is_integer(B), 0 =< B, B =< 255 ->
    [];
bytes(B, 2) when is_integer(B), 0 =< B, B =< 255 ->
    [B,B];
bytes(B, N) when is_integer(B), 0 =< B, B =< 255, is_integer(N), N > 0 ->
    [B,bytes(B, N - 1)].

iterate(Start, Done, Fun) when is_function(Fun) ->
    iterate(Start, Done, Fun, Start).

iterate(Done, Done, _Fun, I) ->
    I;
iterate(I, Done, Fun, _) ->
    iterate(Fun(I), Done, Fun, I).

flush() ->
    flush([]).

flush(Msgs) ->
    receive
        Msg ->
            flush([Msg|Msgs])
    after
        0 -> lists:reverse(Msgs)
    end.

run_large_file_test(Config, Run, Name) ->
    case {os:type(),os:version()} of
        {{win32,nt},_} ->
            do_run_large_file_test(Config, Run, Name);
        {{unix,sunos},OsVersion} when OsVersion < {5,5,1} ->
            {skip,"Only supported on Win32, Unix or SunOS >= 5.5.1"};
        {{unix,_},_} ->
            N = disc_free(test_server:lookup_config(priv_dir, Config)),
            io:format("Free disk: ~w KByte~n", [N]),
            if
                N < 5 * (1 bsl 20) ->
                    {skip,"Less than 5 GByte free"};
                true ->
                    do_run_large_file_test(Config, Run, Name)
            end;
        _ ->
            {skip,"Only supported on Win32, Unix or SunOS >= 5.5.1"}
    end.

do_run_large_file_test(Config, Run, Name0) ->
    Name =
        filename:join(test_server:lookup_config(priv_dir, Config),
                      "file_SUITE" ++ Name0),
    Tester = self(),
    Deleter =
        spawn(fun() ->
                     Mref = monitor(process, Tester),
                     receive
                         {'DOWN',Mref,_,_,_} ->
                             ok;
                         {Tester,done} ->
                             ok
                     end,
                     file:delete(Name)
              end),
    Res = Run(Name),
    Mref = monitor(process, Deleter),
    Deleter ! {Tester,done},
    receive
        {'DOWN',Mref,_,_,_} ->
            ok
    end,
    Res.

disc_free(Path) ->
    Data = disksup:get_disk_data(),
    {_,Tot,Perc} =
        hd(lists:filter(fun({P,_Size,_Full}) ->
                               lists:prefix(filename:nativename(P),
                                            filename:nativename(Path))
                        end,
                        lists:reverse(lists:sort(Data)))),
    round(Tot * (1 - Perc / 100)).

memsize() ->
    {Tot,_Used,_} = memsup:get_memory_data(),
    Tot.

rm_rf(Mod, Dir) ->
    case Mod:read_link_info(Dir) of
        {ok,#file_info{type = directory}} ->
            {ok,Content} = Mod:list_dir_all(Dir),
            [ 
             rm_rf(Mod, filename:join(Dir, C)) ||
                 C <- Content
            ],
            Mod:del_dir(Dir),
            ok;
        {ok,#file_info{}} ->
            Mod:delete(Dir);
        _ ->
            ok
    end.



