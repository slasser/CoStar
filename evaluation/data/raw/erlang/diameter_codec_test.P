-file("test/lib/diameter/test/diameter_codec_test.erl", 1).

-module(diameter_codec_test).

-export([base/0,gen/1,lib/0]).

-file("/Users/parrt/Downloads/fenollp-erlang-grammar-c1db83d09307/test/lib/diameter/test/../include/diameter.hrl",
      1).

-record(diameter_event,{service,info}).

-record(diameter_packet,{header,avps,msg,bin,errors = [],transport_data}).

-record(diameter_header,{version,
                         length,
                         cmd_code,
                         application_id,
                         hop_by_hop_id,
                         end_to_end_id,
                         is_request,
                         is_proxiable,
                         is_error,
                         is_retransmitted}).

-record(diameter_avp,{code,
                      vendor_id,
                      is_mandatory = false,
                      need_encryption = false,
                      data,
                      name,
                      value,
                      type,
                      index}).

-record(diameter_caps,{origin_host,
                       origin_realm,
                       host_ip_address = [],
                       vendor_id,
                       product_name,
                       origin_state_id = [],
                       supported_vendor_id = [],
                       auth_application_id = [],
                       inband_security_id = [],
                       acct_application_id = [],
                       vendor_specific_application_id = [],
                       firmware_revision = [],
                       avp = []}).

-record(diameter_uri,{type,
                      fqdn,
                      port = 3868,
                      transport = sctp,
                      protocol = diameter}).

-record(diameter_callback,{peer_up,
                           peer_down,
                           pick_peer,
                           prepare_request,
                           prepare_retransmit,
                           handle_request,
                           handle_answer,
                           handle_error,
                           default,
                           extra = []}).

-record(diameter_service,{pid,capabilities,applications = []}).

-record(diameter_app,{alias,
                      dictionary,
                      module,
                      init_state,
                      id,
                      mutable = false,
                      options =
                          [{answer_errors,report},
                           {request_errors,answer_3xxx}]}).

-file("test/lib/diameter/test/diameter_codec_test.erl", 32).

base() ->
    [] =
        run([ 
             [fun base/1,T] ||
                 T <- [zero,decode]
            ]).

gen(Mod) ->
    Fs =
        [ 
         {Mod,F,[]} ||
             F <- [name,id,vendor_id,vendor_name]
        ],
    [] =
        run(Fs
            ++
            [ 
             [fun gen/2,Mod,T] ||
                 T <-
                     [messages,
                      command_codes,
                      avp_types,
                      grouped,
                      enum,
                      import_avps,
                      import_groups,
                      import_enums]
            ]).

lib() ->
    Vs = {_,_,_} = values('Address'),
    [] =
        run([ 
             [fun lib/2,N,Vs] ||
                 N <- [{1,true},{3,false}]
            ]).

lib({N,B}, {_,_,_} = T) ->
    [] =
        run([ 
             [fun lib/2,A,B] ||
                 A <- element(N, T),
                 is_tuple(A)
            ]);
lib(IP, B) ->
    [] =
        run([ 
             [fun lib/3,IP,B,A] ||
                 A <- [IP,ntoa(tuple_to_list(IP))]
            ]).

lib(IP, B, A) ->
    try diameter_lib:ipaddr(A) of
        IP when B ->
            ok
    catch
        error:_ when not B ->
            ok
    end.

ntoa([_,_,_,_] = A) ->
    [$.|S] =
        lists:append([ 
                      "." ++ integer_to_list(N) ||
                          N <- A
                     ]),
    S;
ntoa([_,_,_,_,_,_,_,_] = A) ->
    [$:|S] =
        lists:flatten([ 
                       ":" ++ io_lib:format("~.16B", [N]) ||
                           N <- A
                      ]),
    S.

base(T) ->
    [] =
        run([ 
             [fun base/2,T,F] ||
                 F <- types()
            ]).

base(zero = T, F) ->
    B = diameter_types:F(encode, T),
    B = z(B);
base(decode, F) ->
    {Ts,Fs,Is} = values(F),
    [] =
        run([ 
             [fun base_decode/3,F,true,V] ||
                 V <- Ts
            ]),
    [] =
        run([ 
             [fun base_decode/3,F,false,V] ||
                 V <- Fs
            ]),
    [] =
        run([ 
             [fun base_invalid/2,F,V] ||
                 V <- Is
            ]).

base_decode(F, Eq, Value) ->
    d(fun(X, V) ->
             diameter_types:F(X, V)
      end,
      Eq,
      Value).

base_invalid(F, Value) ->
    try
        base_decode(F, false, Value),
        exit(nok)
    catch
        error:_ ->
            ok
    end.

types() ->
    [ 
     F ||
         {F,2} <- diameter_types:module_info(exports)
    ].

gen(M, T) ->
    [] =
        run(lists:map(fun(X) ->
                             [fun gen/3,M,T,X]
                      end,
                      fetch(T, dict(M)))).

fetch(T, Spec) ->
    case orddict:find(T, Spec) of
        {ok,L} ->
            L;
        error ->
            []
    end.

gen(M, messages = T, {Name,Code,Flags,ApplId,Avps}) when is_list(Name) ->
    gen(M, T, {list_to_atom(Name),Code,Flags,ApplId,Avps});
gen(M, messages, {Name,Code,Flags,_,_}) ->
    Rname = M:msg2rec(Name),
    Name = M:rec2msg(Rname),
    {Code,F,_} = M:msg_header(Name),
    0 = F band 15,
    Name =
        case M:msg_name(Code, lists:member('REQ', Flags)) of
            N when Name /= 'answer-message' ->
                N;
            ''
                when
                    Name == 'answer-message',
                    M == diameter_gen_base_rfc3588
                    orelse
                    M == diameter_gen_base_rfc6733 ->
                Name
        end,
    [] = arity(M, Name, Rname);
gen(M, command_codes, {Code,Req,Ans}) ->
    Msgs = orddict:fetch(messages, dict(M)),
    {_,Code,_,_,_} = lists:keyfind(Req, 1, Msgs),
    {_,Code,_,_,_} = lists:keyfind(Ans, 1, Msgs);
gen(M, avp_types = T, {Name,Code,Type,Flags}) when is_list(Name) ->
    gen(M, T, {list_to_atom(Name),Code,list_to_atom(Type),Flags});
gen(M, avp_types, {Name,Code,Type,_Flags}) ->
    {Code,Flags,VendorId} = M:avp_header(Name),
    0 = Flags band 31,
    V = undefined /= VendorId,
    V = 0 /= Flags band 128,
    {Name,Type} = M:avp_name(Code, VendorId),
    B = M:empty_value(Name),
    B = z(B),
    [] = avp_decode(M, Type, Name);
gen(M, grouped = T, {Name,Code,Vid,Avps}) when is_list(Name) ->
    gen(M, T, {list_to_atom(Name),Code,Vid,Avps});
gen(M, grouped, {Name,_,_,_}) ->
    Rname = M:name2rec(Name),
    [] = arity(M, Name, Rname);
gen(M, enum = T, {Name,ED}) when is_list(Name) ->
    gen(M,
        T,
        {list_to_atom(Name),
         lists:map(fun({E,D}) ->
                          {list_to_atom(E),D}
                   end,
                   ED)});
gen(M, enum, {Name,ED}) ->
    [] =
        run([ 
             [fun enum/3,M,Name,T] ||
                 T <- ED
            ]);
gen(M, Tag, {_Mod,L}) ->
    T = retag(Tag),
    [] =
        run([ 
             [fun gen/3,M,T,I] ||
                 I <- L
            ]).

avp_decode(Mod, Type, Name) ->
    {Ts,Fs,_} = values(Type, Name, Mod),
    [] =
        run([ 
             [fun avp_decode/5,Mod,Name,Type,true,V] ||
                 V <- v(Ts)
            ]),
    [] =
        run([ 
             [fun avp_decode/5,Mod,Name,Type,false,V] ||
                 V <- v(Fs)
            ]).

avp_decode(Mod, Name, Type, Eq, Value) ->
    d(fun(X, V) ->
             avp(Mod, X, V, Name, Type)
      end,
      Eq,
      Value).

avp(Mod, decode = X, V, Name, 'Grouped') ->
    {Rec,_} = Mod:avp(X, V, Name),
    Rec;
avp(Mod, X, V, Name, _) ->
    Mod:avp(X, V, Name).

v(Vs) when is_list(Vs) ->
    Vs;
v(E) ->
    v(2000, E(0), E).

v(Max, Ord, E) when Ord =< Max ->
    diameter_enum:to_list(E);
v(Max, Ord, E) ->
    {M,S,U} = now(),
    random:seed(M, S, U),
    v(Max, Ord, E, []).

v(0, _, _, Acc) ->
    Acc;
v(N, Ord, E, Acc) ->
    v(N - 1, Ord, E, [E(random:uniform(Ord))|Acc]).

arity(M, Name, Rname) ->
    Rec = M:'#new-'(Rname),
    [] =
        run([ 
             [fun arity/4,M,Name,F,Rec] ||
                 F <- M:'#info-'(Rname, fields)
            ]).

arity(M, Name, AvpName, Rec) ->
    Def = M:'#get-'(AvpName, Rec),
    Def =
        case M:avp_arity(Name, AvpName) of
            1 ->
                undefined;
            A when 0 /= A ->
                []
        end.

enum(M, Name, {_,E}) ->
    B = <<E:32>>,
    B = M:avp(encode, E, Name),
    E = M:avp(decode, B, Name).

retag(import_avps) ->
    avp_types;
retag(import_groups) ->
    grouped;
retag(import_enums) ->
    enum;
retag(avp_types) ->
    import_avps;
retag(enum) ->
    import_enums.

d(F, Eq, V) ->
    B = F(encode, V),
    D = F(decode, B),
    V = if
            Eq ->
                D;
            true ->
                D = F(decode, F(encode, D)),
                V
        end.

z(B) ->
    << 
      <<0>> ||
          <<_>> <= B
    >>.

values('OctetString' = T) ->
    {["",atom_to_list(T)],[],[- 1,256]};
values('Integer32') ->
    Mx = 1 bsl 31 - 1,
    Mn = - 1 * Mx,
    {[Mn,0,random(Mn, Mx),Mx],[],[Mn - 1,Mx + 1]};
values('Integer64') ->
    Mx = 1 bsl 63 - 1,
    Mn = - 1 * Mx,
    {[Mn,0,random(Mn, Mx),Mx],[],[Mn - 1,Mx + 1]};
values('Unsigned32') ->
    M = 1 bsl 32 - 1,
    {[0,random(M),M],[],[- 1,M + 1]};
values('Unsigned64') ->
    M = 1 bsl 64 - 1,
    {[0,random(M),M],[],[- 1,M + 1]};
values('Float32') ->
    E = 1 bsl 8 - 2,
    F = 1 bsl 23 - 1,
    <<Mx:32/float>> = <<0:1,E:8,F:23>>,
    <<Mn:32/float>> = <<1:1,E:8,F:23>>,
    {[0.0,infinity,'-infinity',Mx,Mn],[],[0]};
values('Float64') ->
    E = 1 bsl 11 - 2,
    F = 1 bsl 52 - 1,
    <<Mx:64/float>> = <<0:1,E:11,F:52>>,
    <<Mn:64/float>> = <<1:1,E:11,F:52>>,
    {[0.0,infinity,'-infinity',Mx,Mn],[],[0]};
values('Address') ->
    {[{255,0,random(255),1},{65535,0,0,random(65535),0,0,0,1}],
     ["127.0.0.1","FFFF:FF::1.2.3.4"],
     [{256,0,0,1},{65536,0,0,0,0,0,0,1},"256.0.0.1","10000::1"]};
values('DiameterIdentity') ->
    {["x","diameter.com"],[],[""]};
values('DiameterURI') ->
    {[],
     [ 
      "aaa" ++ S ++ "://diameter.se" ++ P ++ Tr ++ Pr ||
          S <- ["","s"],
          P <- ["",":1234"],
          Tr <-
              [""|
               [ 
                ";transport=" ++ X ||
                    X <- ["tcp","sctp","udp"]
               ]],
          Pr <-
              [""|
               [ 
                ";protocol=" ++ X ||
                    X <- ["diameter","radius","tacacs+"]
               ]]
     ],
     []};
values(T) when T == 'IPFilterRule'; T == 'QoSFilterRule' ->
    {["deny in 0 from 127.0.0.1 to 10.0.0.1"],[],[]};
values('UTF8String') ->
    S = "р\232ар\232бр\232др\232ер\232▒р\232▓",
    B = unicode:characters_to_binary(S),
    {[[],
      S,
      lists:seq(0, 511),
      [0,55295,57344,1114111],
      [random(55295),random(57344, 1114111)]],
     [B,[B,S,hd(S)],[S,B]],
     [[- 1],[55296],[57343],[1114112]]};
values('Time') ->
    {[{{1968,1,20},{3,14,8}},
      {date(),time()},
      {{2036,2,7},{6,28,15}},
      {{2036,2,7},{6,28,16}},
      {{2104,2,26},{9,42,23}}],
     [],
     [{{1968,1,20},{3,14,7}},{{2104,2,26},{9,42,24}}]}.

values('Enumerated', Name, Mod) ->
    {_Name,Vals} =
        lists:keyfind(atom_to_list(Name), 1, types(enum, Mod)),
    {lists:map(fun({_,N}) ->
                      N
               end,
               Vals),
     [],
     []};
values('Grouped', Name, Mod) ->
    Rname = Mod:name2rec(Name),
    Rec = Mod:'#new-'(Rname),
    Avps = Mod:'#info-'(Rname, fields),
    Enum =
        diameter_enum:combine(lists:map(fun({Vs,_,_}) ->
                                               to_enum(Vs)
                                        end,
                                        [ 
                                         values(F, Mod) ||
                                             F <- Avps
                                        ])),
    {[],diameter_enum:append(group(Mod, Name, Rec, Avps, Enum)),[]};
values(_, 'Framed-IP-Address', _) ->
    {[{127,0,0,1}],[],[]};
values(Type, _, _) ->
    values(Type).

to_enum(Vs) when is_list(Vs) ->
    diameter_enum:new(Vs);
to_enum(E) ->
    E.

values('AVP', _) ->
    {[#diameter_avp{code = 0,data = <<0>>}],[],[]};
values(Name, Mod) ->
    Avps = types(avp_types, Mod),
    {_Name,_Code,Type,_Flags} =
        lists:keyfind(atom_to_list(Name), 1, Avps),
    values(list_to_atom(Type), Name, Mod).

group(Mod, Name, Rec, Avps, Enum) ->
    lists:map(fun(B) ->
                     group(Mod, Name, Rec, Avps, Enum, B)
              end,
              [ 
               {A,R} ||
                   A <- [true,false],
                   R <- [true,false]
              ]).

group(Mod, Name, Rec, Avps, Enum, B) ->
    diameter_enum:map(fun(Vs) ->
                             g(Mod, Name, Rec, Avps, Vs, B)
                      end,
                      Enum).

g(Mod, Name, Rec, Avps, Values, {All,AsRec}) ->
    {Tagged,[]} =
        lists:foldl(fun(N, {A,[V|Vs]}) ->
                           {pack(All, Mod:avp_arity(Name, N), N, V, A),
                            Vs}
                    end,
                    {[],Values},
                    Avps),
    g(AsRec, Mod, Tagged, Rec).

g(true, Mod, Vals, Rec) ->
    Mod:'#set-'(Vals, Rec);
g(false, _, Vals, _) ->
    Vals.

pack(true, Arity, Avp, Value, Acc) ->
    [all(Arity, Avp, Value)|Acc];
pack(false, Arity, Avp, Value, Acc) ->
    min(Arity, Avp, Value, Acc).

all(Mod, Name, Avp, V) ->
    all(Mod:avp_arity(Name, Avp), Avp, V).

all(1, Avp, V) ->
    {Avp,V};
all({0,'*'}, Avp, V) ->
    a(1, Avp, V);
all({N,'*'}, Avp, V) ->
    a(N, Avp, V);
all({_,N}, Avp, V) ->
    a(N, Avp, V).

a(N, Avp, V) when N /= 0 ->
    {Avp,lists:duplicate(N, V)}.

min(Mod, Name, Avp, V, Acc) ->
    min(Mod:avp_arity(Name, Avp), Avp, V, Acc).

min(1, Avp, V, Acc) ->
    [{Avp,V}|Acc];
min({0,_}, _, _, Acc) ->
    Acc;
min({N,_}, Avp, V, Acc) ->
    [{Avp,lists:duplicate(N, V)}|Acc].

types(T, Mod) ->
    types(T, retag(T), Mod).

types(T, IT, Mod) ->
    Dict = dict(Mod),
    fetch(T, Dict)
    ++
    lists:flatmap(fun({_,As}) ->
                         As
                  end,
                  fetch(IT, Dict)).

random(M) ->
    random(0, M).

random(Mn, Mx) ->
    seed(get({diameter_codec_test,seed})),
    Mn + random:uniform(Mx - Mn + 1) - 1.

seed(undefined) ->
    put({diameter_codec_test,seed}, true),
    random:seed(now());
seed(true) ->
    ok.

run(L) ->
    lists:flatmap(fun flatten/1, diameter_util:run(L)).

flatten({_,{{badmatch,[{_,{{badmatch,_},_}}|_] = L},_}}) ->
    L;
flatten(T) ->
    [T].

dict(Mod) ->
    tl(Mod:dict()).



