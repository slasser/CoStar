-file("test/lib/edoc/src/edoc_layout.erl", 1).

-module(edoc_layout).

-export([module/2,package/2,overview/2,type/1]).

-import(edoc_report, [report/2]).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/xmerl-1.3.2/include/xmerl.hrl",
      1).

-record(xmlDecl,{vsn,encoding,standalone,attributes}).

-record(xmlAttribute,{name,
                      expanded_name = [],
                      nsinfo = [],
                      namespace = [],
                      parents = [],
                      pos,
                      language = [],
                      value,
                      normalized}).

-record(xmlNamespace,{default = [],nodes = []}).

-record(xmlNsNode,{parents = [],pos,prefix,uri = []}).

-record(xmlElement,{name,
                    expanded_name = [],
                    nsinfo = [],
                    namespace = #xmlNamespace{},
                    parents = [],
                    pos,
                    attributes = [],
                    content = [],
                    language = "",
                    xmlbase = "",
                    elementdef = undeclared}).

-record(xmlText,{parents = [],pos,language = [],value,type = text}).

-record(xmlComment,{parents = [],pos,language = [],value}).

-record(xmlPI,{name,parents = [],pos,value}).

-record(xmlDocument,{content}).

-record(xmlContext,{axis_type = forward,
                    context_node,
                    context_position = 1,
                    nodeset = [],
                    bindings = [],
                    functions = [],
                    namespace = [],
                    whole_document}).

-record(xmlNode,{type = element,node,parents = [],pos = 1}).

-record(xmlObj,{type,value}).

-record(xmerl_fun_states,{event,hook,rules,fetch,cont}).

-record(xmerl_scanner,{encoding = undefined,
                       standalone = no,
                       environment = prolog,
                       declarations = [],
                       doctype_name,
                       doctype_DTD = internal,
                       comments = true,
                       document = false,
                       default_attrs = false,
                       rules,
                       keep_rules = false,
                       namespace_conformant = false,
                       xmlbase,
                       xmlbase_cache,
                       fetch_path = [],
                       filename = file_name_unknown,
                       validation = off,
                       schemaLocation = [],
                       space = preserve,
                       event_fun,
                       hook_fun,
                       acc_fun,
                       fetch_fun,
                       close_fun,
                       continuation_fun,
                       rules_read_fun,
                       rules_write_fun,
                       rules_delete_fun,
                       user_state,
                       fun_states = #xmerl_fun_states{},
                       entity_references = [],
                       text_decl = false,
                       quiet = false,
                       col = 1,
                       line = 1,
                       common_data = []}).

-record(xmerl_event,{event,line,col,pos,data}).

-file("test/lib/edoc/src/edoc_layout.erl", 35).

module(Element, Options) ->
    XML = layout_module(Element, init_opts(Element, Options)),
    Export = proplists:get_value(xml_export, Options, xmerl_html),
    xmerl:export_simple(XML, Export, []).

-record(opts,{root,
              stylesheet,
              index_columns,
              sort_functions,
              pretty_printer}).

init_opts(Element, Options) ->
    R = #opts{root = get_attrval(root, Element),
              index_columns =
                  proplists:get_value(index_columns, Options, 1),
              sort_functions =
                  proplists:get_value(sort_functions, Options, true),
              pretty_printer =
                  proplists:get_value(pretty_printer, Options, '')},
    case proplists:get_value(stylesheet, Options) of
        undefined ->
            S = edoc_lib:join_uri(R#opts.root, "stylesheet.css"),
            R#opts{stylesheet = S};
        "" ->
            R;
        S when is_list(S) ->
            R#opts{stylesheet = S};
        _ ->
            report("bad value for option `stylesheet'.", []),
            exit(error)
    end.

layout_module(#xmlElement{name = module,content = Es} = E, Opts) ->
    Args = module_params(get_content(args, Es)),
    Name = get_attrval(name, E),
    Title =
        case get_elem(args, Es) of
            [] ->
                ["Module ",Name];
            _ ->
                ["Abstract module ",Name," [",{Args},"]"]
        end,
    Desc = get_content(description, Es),
    ShortDesc = get_content(briefDescription, Desc),
    FullDesc = get_content(fullDescription, Desc),
    Functions =
        [ 
         {function_name(E),E} ||
             E <- get_content(functions, Es)
        ],
    Types =
        [ 
         {type_name(E),E} ||
             E <- get_content(typedecls, Es)
        ],
    SortedFs = lists:sort(Functions),
    Body =
        navigation("top")
        ++
        ["\n",hr,"\n","\n",{h1,Title},"\n"]
        ++
        doc_index(FullDesc, Functions, Types)
        ++
        ShortDesc
        ++
        ["\n"]
        ++
        copyright(Es)
        ++
        deprecated(Es, "module")
        ++
        ["\n"]
        ++
        version(Es)
        ++
        since(Es)
        ++
        behaviours(Es, Name)
        ++
        authors(Es)
        ++
        references(Es)
        ++
        sees(Es)
        ++
        todos(Es)
        ++
        if
            FullDesc == [] ->
                [];
            true ->
                ["\n",
                 {h2,[{a,[{name,"description"}],["Description"]}]}|
                 FullDesc]
        end
        ++
        types(lists:sort(Types), Opts)
        ++
        function_index(SortedFs, Opts#opts.index_columns)
        ++
        if
            Opts#opts.sort_functions ->
                functions(SortedFs, Opts);
            true ->
                functions(Functions, Opts)
        end
        ++
        [hr,"\n"] ++ navigation("bottom") ++ timestamp(),
    Encoding = get_attrval(encoding, E),
    xhtml(Title, stylesheet(Opts), Body, Encoding).

module_params(Es) ->
    As =
        [ 
         {get_text(argName, Es1),
          get_content(fullDescription, get_content(description, Es1))} ||
             #xmlElement{content = Es1} <- Es
        ],
    case As of
        [] ->
            [];
        [First|Rest] ->
            [element(1, First)|
             [ 
              {[", ",A]} ||
                  {A,_D} <- Rest
             ]]
    end.

timestamp() ->
    ["\n",
     {p,
      [{i,
        [io_lib:fwrite("Generated by EDoc, ~s, ~s.",
                       [edoc_lib:datestr(date()),
                        edoc_lib:timestr(time())])]}]},
     "\n"].

stylesheet(Opts) ->
    case Opts#opts.stylesheet of
        undefined ->
            [];
        CSS ->
            [{link,
              [{rel,"stylesheet"},
               {type,"text/css"},
               {href,CSS},
               {title,"EDoc"}],
              []},
             "\n"]
    end.

navigation(Where) ->
    ["\n",
     {'div',
      [{class,"navbar"}],
      [{a,[{name,"#navbar_" ++ Where}],[]},
       {table,
        [{width,"100%"},
         {border,0},
         {cellspacing,0},
         {cellpadding,2},
         {summary,"navigation bar"}],
        [{tr,
          [{td,
            [{a,
              [{href,"overview-summary.html"},{target,"overviewFrame"}],
              ["Overview"]}]},
           {td,
            [{a,
              [{href,"http://www.erlang.org/"}],
              [{img,
                [{src,"erlang.png"},
                 {align,"right"},
                 {border,0},
                 {alt,"erlang logo"}],
                []}]}]}]}]}]}].

doc_index(FullDesc, Functions, Types) ->
    case doc_index_rows(FullDesc, Functions, Types) of
        [] ->
            [];
        Rs ->
            [{ul,
              [{class,"index"}],
              [ 
               {li,[{a,[{href,local_label(R)}],[T]}]} ||
                   {T,R} <- Rs
              ]}]
    end.

doc_index_rows(FullDesc, Functions, Types) ->
    if
        FullDesc == [] ->
            [];
        true ->
            [{"Description","description"}]
    end
    ++
    if
        Types == [] ->
            [];
        true ->
            [{"Data Types","types"}]
    end
    ++
    if
        Functions == [] ->
            [];
        true ->
            [{"Function Index","index"},
             {"Function Details","functions"}]
    end.

function_index(Fs, Cols) ->
    case function_index_rows(Fs, Cols, []) of
        [] ->
            [];
        Rows ->
            ["\n",
             {h2,[{a,[{name,"index"}],["Function Index"]}]},
             "\n",
             {table,
              [{width,"100%"},
               {border,1},
               {cellspacing,0},
               {cellpadding,2},
               {summary,"function index"}],
              Rows},
             "\n"]
    end.

function_index_rows(Fs, Cols, Title) ->
    Rows = (length(Fs) + (Cols - 1)) div Cols,
    if
        Title == [] ->
            [];
        true ->
            [{tr,[{th,[{colspan,Cols * 2},{align,left}],[Title]}]},"\n"]
    end
    ++
    lists:flatmap(fun index_row/1,
                  edoc_lib:transpose(edoc_lib:segment(Fs, Rows))).

index_row(Fs) ->
    [{tr,lists:flatmap(fun index_col/1, Fs)},"\n"].

index_col({Name,F = #xmlElement{content = Es}}) ->
    [{td,[{valign,"top"}],label_href(function_header(Name, F, "*"), F)},
     {td,index_desc(Es)}].

index_desc(Es) ->
    Desc = get_content(description, Es),
    case get_content(deprecated, Es) of
        [] ->
            [];
        _ ->
            ["(",{em,["Deprecated"]},".) "]
    end
    ++
    case get_content(briefDescription, Desc) of
        [] ->
            equiv(Es);
        ShortDesc ->
            ShortDesc
    end.

label_href(Content, F) ->
    case get_attrval(label, F) of
        "" ->
            Content;
        Ref ->
            [{a,[{href,local_label(Ref)}],Content}]
    end.

functions(Fs, Opts) ->
    Es =
        lists:flatmap(fun({Name,E}) ->
                             function(Name, E, Opts)
                      end,
                      Fs),
    if
        Es == [] ->
            [];
        true ->
            ["\n",
             {h2,[{a,[{name,"functions"}],["Function Details"]}]},
             "\n"|
             Es]
    end.

function(Name, E = #xmlElement{content = Es}, Opts) ->
    ["\n",
     {h3,
      [{class,"function"}],
      label_anchor(function_header(Name, E, " *"), E)},
     "\n"]
    ++
    [{'div',
      [{class,"spec"}],
      ["\n",
       {p,
        case typespec(get_content(typespec, Es), Opts) of
            [] ->
                signature(get_content(args, Es), get_attrval(name, E));
            Spec ->
                Spec
        end},
       "\n"]
      ++
      case params(get_content(args, Es)) of
          [] ->
              [];
          Ps ->
              [{p,Ps},"\n"]
      end
      ++
      case returns(get_content(returns, Es)) of
          [] ->
              [];
          Rs ->
              [{p,Rs},"\n"]
      end}]
    ++
    throws(Es, Opts)
    ++
    equiv_p(Es)
    ++
    deprecated(Es, "function")
    ++
    fulldesc(Es) ++ since(Es) ++ sees(Es) ++ todos(Es).

function_name(E) ->
    atom(get_attrval(name, E)) ++ "/" ++ get_attrval(arity, E).

function_header(Name, E, Private) ->
    case is_exported(E) of
        true ->
            [Name];
        false ->
            [Name,Private]
    end.

is_exported(E) ->
    case get_attrval(exported, E) of
        "yes" ->
            true;
        _ ->
            false
    end.

label_anchor(Content, E) ->
    case get_attrval(label, E) of
        "" ->
            Content;
        Ref ->
            [{a,[{name,Ref}],Content}]
    end.

signature(Es, Name) ->
    [{tt,[Name,"("] ++ seq(fun arg/1, Es) ++ [") -> any()"]}].

arg(#xmlElement{content = Es}) ->
    [get_text(argName, Es)].

params(Es) ->
    As =
        [ 
         {get_text(argName, Es1),
          get_content(fullDescription, get_content(description, Es1))} ||
             #xmlElement{content = Es1} <- Es
        ],
    As1 =
        [ 
         A ||
             A <- As,
             element(2, A) /= []
        ],
    if
        As1 == [] ->
            [];
        true ->
            [ 
             {[{tt,[A]},": "] ++ D ++ [br,"\n"]} ||
                 {A,D} <- As1
            ]
    end.

returns(Es) ->
    case get_content(fullDescription, get_content(description, Es)) of
        [] ->
            [];
        D ->
            ["returns: "] ++ D
    end.

throws(Es, Opts) ->
    case get_content(throws, Es) of
        [] ->
            [];
        Es1 ->
            [{p,
              ["throws ",{tt,t_utype(get_elem(type, Es1))}]
              ++
              local_defs(get_elem(localdef, Es1), Opts)},
             "\n"]
    end.

typespec([], _Opts) ->
    [];
typespec(Es, Opts) ->
    Name = t_name(get_elem(erlangName, Es)),
    Defs = get_elem(localdef, Es),
    [Type] = get_elem(type, Es),
    format_spec(Name, Type, Defs, Opts) ++ local_defs(Defs, Opts).

types([], _Opts) ->
    [];
types(Ts, Opts) ->
    Es =
        lists:flatmap(fun({Name,E}) ->
                             typedecl(Name, E, Opts)
                      end,
                      Ts),
    ["\n",{h2,[{a,[{name,"types"}],["Data Types"]}]},"\n"|Es].

typedecl(Name, E = #xmlElement{content = Es}, Opts) ->
    ["\n",{h3,[{class,"typedecl"}],label_anchor([Name,"()"], E)},"\n"]
    ++
    [{p,typedef(get_content(typedef, Es), Opts)},"\n"] ++ fulldesc(Es).

type_name(#xmlElement{content = Es}) ->
    t_name(get_elem(erlangName, get_content(typedef, Es))).

typedef(Es, Opts) ->
    Name =
        [t_name(get_elem(erlangName, Es)),"("]
        ++
        seq(fun t_utype_elem/1, get_content(argtypes, Es), [")"]),
    case get_elem(type, Es) of
        [] ->
            [{b,["abstract datatype"]},": ",{tt,Name}];
        Type ->
            format_type(Name, Name, Type, [], Opts)
    end
    ++
    local_defs(get_elem(localdef, Es), Opts).

local_defs(Es, Opts) ->
    local_defs(Es, [], Opts).

local_defs([], _, _Opts) ->
    [];
local_defs(Es0, Last, Opts) ->
    [E|Es] = lists:reverse(Es0),
    ["\n",
     {ul,
      [{class,"definitions"}],
      lists:reverse(lists:append([ 
                                  localdef(E1, [], Opts) ||
                                      E1 <- Es
                                 ]),
                    localdef(E, Last, Opts))}].

localdef(E = #xmlElement{content = Es}, Last, Opts) ->
    Name =
        case get_elem(typevar, Es) of
            [] ->
                label_anchor(N0 = t_abstype(get_content(abstype, Es)),
                             E);
            [V] ->
                N0 = t_var(V)
        end,
    [{li,format_type(Name, N0, get_elem(type, Es), Last, Opts)}].

format_spec(Name, Type, Defs, #opts{pretty_printer = erl_pp} = Opts) ->
    try
        L = t_clause(Name, Type),
        O = pp_clause(Name, Type),
        {R,".\n"} = etypef(L, O),
        [{pre,R}]
    catch
        _:_ ->
            format_spec(Name,
                        Type,
                        Defs,
                        Opts#opts{pretty_printer = ''})
    end;
format_spec(Sep, Type, Defs, _Opts) ->
    Br =
        if
            Defs =:= [] ->
                br;
            true ->
                []
        end,
    [{tt,t_clause(Sep, Type)},Br].

t_clause(Name, Type) ->
    #xmlElement{content = [#xmlElement{name = 'fun',content = C}]} =
        Type,
    [Name] ++ t_fun(C).

pp_clause(Pre, Type) ->
    Types = ot_utype([Type]),
    Atom = lists:duplicate(iolist_size(Pre), $a),
    L1 =
        erl_pp:attribute({attribute,
                          0,
                          spec,
                          {{list_to_atom(Atom),0},[Types]}}),
    "-spec " ++ L2 = lists:flatten(L1),
    L3 = Pre ++ lists:nthtail(length(Atom), L2),
    re:replace(L3, "\n      ", "\n", [{return,list},global]).

format_type(Prefix,
            Name,
            Type,
            Last,
            #opts{pretty_printer = erl_pp} = Opts) ->
    try
        L = t_utype(Type),
        O = pp_type(Name, Type),
        {R,".\n"} = etypef(L, O),
        [{pre,Prefix ++ [" = "] ++ R ++ Last}]
    catch
        _:_ ->
            format_type(Prefix,
                        Name,
                        Type,
                        Last,
                        Opts#opts{pretty_printer = ''})
    end;
format_type(Prefix, _Name, Type, Last, _Opts) ->
    [{tt,Prefix ++ [" = "] ++ t_utype(Type) ++ Last}].

pp_type(Prefix, Type) ->
    Atom = list_to_atom(lists:duplicate(iolist_size(Prefix), $a)),
    L1 = erl_pp:attribute({attribute,0,type,{Atom,ot_utype(Type),[]}}),
    {L2,N} =
        case
            lists:dropwhile(fun(C) ->
                                   C =/= $:
                            end,
                            lists:flatten(L1))
        of
            ":: " ++ L3 ->
                {L3,9};
            "::\n" ++ L3 ->
                {"\n" ++ L3,6}
        end,
    Ss = lists:duplicate(N, $\s),
    re:replace(L2, "\n" ++ Ss, "\n", [{return,list},global]).

etypef(L, O0) ->
    {R,O} = etypef(L, [], O0, []),
    {lists:reverse(R),O}.

etypef([C|L], St, [C|O], R) ->
    etypef(L, St, O, [[C]|R]);
etypef(" " ++ L, St, O, R) ->
    etypef(L, St, O, R);
etypef("", [Cs|St], O, R) ->
    etypef(Cs, St, O, R);
etypef("", [], O, R) ->
    {R,O};
etypef(L, St, " " ++ O, R) ->
    etypef(L, St, O, [" "|R]);
etypef(L, St, "\n" ++ O, R) ->
    Ss =
        lists:takewhile(fun(C) ->
                               C =:= $\s
                        end,
                        O),
    etypef(L, St, lists:nthtail(length(Ss), O), ["\n" ++ Ss|R]);
etypef([{a,HRef,S0}|L], St, O0, R) ->
    {S,O} = etypef(S0, app_fix(O0)),
    etypef(L, St, O, [{a,HRef,S}|R]);
etypef("=" ++ L, St, "::" ++ O, R) ->
    etypef(L, St, O, ["="|R]);
etypef([Cs|L], St, O, R) ->
    etypef(Cs, [L|St], O, R).

app_fix(L) ->
    try
        {"//" ++ R1,L2} = app_fix(L, 1),
        [App,Mod] = string:tokens(R1, "/"),
        "//" ++ atom(App) ++ "/" ++ atom(Mod) ++ L2
    catch
        _:_ ->
            L
    end.

app_fix(L, I) ->
    {L1,L2} = lists:split(I, L),
    case erl_scan:tokens([], L1 ++ ". ", 1) of
        {done,{ok,[{atom,_,Atom}|_],_},_} ->
            {atom_to_list(Atom),L2};
        _ ->
            app_fix(L, I + 1)
    end.

fulldesc(Es) ->
    case get_content(fullDescription, get_content(description, Es)) of
        [] ->
            ["\n"];
        Desc ->
            [{p,Desc},"\n"]
    end.

sees(Es) ->
    case get_elem(see, Es) of
        [] ->
            [];
        Es1 ->
            [{p,[{b,["See also:"]}," "] ++ seq(fun see/1, Es1, ["."])},
             "\n"]
    end.

see(E = #xmlElement{content = Es}) ->
    see(E, Es).

see(E, Es) ->
    case href(E) of
        [] ->
            Es;
        Ref ->
            [{a,Ref,Es}]
    end.

href(E) ->
    case get_attrval(href, E) of
        "" ->
            [];
        URI ->
            T = case get_attrval(target, E) of
                    "" ->
                        [];
                    S ->
                        [{target,S}]
                end,
            [{href,URI}|T]
    end.

equiv_p(Es) ->
    equiv(Es, true).

equiv(Es) ->
    equiv(Es, false).

equiv(Es, P) ->
    case get_content(equiv, Es) of
        [] ->
            [];
        Es1 ->
            case get_content(expr, Es1) of
                [] ->
                    [];
                [Expr] ->
                    Expr1 = [{tt,[Expr]}],
                    Expr2 =
                        case get_elem(see, Es1) of
                            [] ->
                                Expr1;
                            [E = #xmlElement{}] ->
                                see(E, Expr1)
                        end,
                    Txt = ["Equivalent to "] ++ Expr2 ++ ["."],
                    case P of
                        true ->
                            [{p,Txt}];
                        false ->
                            Txt
                    end
                    ++
                    ["\n"]
            end
    end.

copyright(Es) ->
    case get_content(copyright, Es) of
        [] ->
            [];
        Es1 ->
            [{p,["Copyright © "|Es1]},"\n"]
    end.

version(Es) ->
    case get_content(version, Es) of
        [] ->
            [];
        Es1 ->
            [{p,[{b,["Version:"]}," "|Es1]},"\n"]
    end.

since(Es) ->
    case get_content(since, Es) of
        [] ->
            [];
        Es1 ->
            [{p,[{b,["Introduced in:"]}," "|Es1]},"\n"]
    end.

deprecated(Es, S) ->
    Es1 = get_content(description, get_content(deprecated, Es)),
    case get_content(fullDescription, Es1) of
        [] ->
            [];
        Es2 ->
            [{p,[{b,["This " ++ S ++ " is deprecated:"]}," "|Es2]},"\n"]
    end.

behaviours(Es, Name) ->
    case get_elem(behaviour, Es) of
        [] ->
            [];
        Es1 ->
            [{p,
              [{b,["Behaviours:"]}," "]
              ++
              seq(fun behaviour/1, Es1, ["."])},
             "\n"]
    end
    ++
    case get_content(callbacks, Es) of
        [] ->
            [];
        Es1 ->
            [{p,
              [{b,
                ["This module defines the ",{tt,[Name]}," behaviour."]},
               br,
               " Required callback functions: "]
              ++
              seq(fun callback/1, Es1, ["."])},
             "\n"]
    end.

behaviour(E = #xmlElement{content = Es}) ->
    see(E, [{tt,Es}]).

callback(E = #xmlElement{}) ->
    Name = get_attrval(name, E),
    Arity = get_attrval(arity, E),
    [{tt,[Name,"/",Arity]}].

authors(Es) ->
    case get_elem(author, Es) of
        [] ->
            [];
        Es1 ->
            [{p,[{b,["Authors:"]}," "] ++ seq(fun author/1, Es1, ["."])},
             "\n"]
    end.

atom(String) ->
    io_lib:write_atom(list_to_atom(String)).

author(E = #xmlElement{}) ->
    Name = get_attrval(name, E),
    Mail = get_attrval(email, E),
    URI = get_attrval(website, E),
    if
        Name == Mail ->
            [{a,[{href,"mailto:" ++ Mail}],[{tt,[Mail]}]}];
        true ->
            if
                Mail == "" ->
                    [Name];
                true ->
                    [Name,
                     " (",
                     {a,[{href,"mailto:" ++ Mail}],[{tt,[Mail]}]},
                     ")"]
            end
    end
    ++
    if
        URI == "" ->
            [];
        true ->
            [" [",
             {em,["web site:"]},
             " ",
             {tt,[{a,[{href,URI},{target,"_top"}],[URI]}]},
             "]"]
    end.

references(Es) ->
    case get_elem(reference, Es) of
        [] ->
            [];
        Es1 ->
            [{p,
              [{b,["References"]},
               {ul,
                [ 
                 {li,C} ||
                     #xmlElement{content = C} <- Es1
                ]}]},
             "\n"]
    end.

todos(Es) ->
    case get_elem(todo, Es) of
        [] ->
            [];
        Es1 ->
            Todos =
                [ 
                 {li,[{font,[{color,red}],C}]} ||
                     #xmlElement{content = C} <- Es1
                ],
            [{p,[{b,[{font,[{color,red}],["To do"]}]},{ul,Todos}]},"\n"]
    end.

t_name([E]) ->
    N = get_attrval(name, E),
    case get_attrval(module, E) of
        "" ->
            atom(N);
        M ->
            S = atom(M) ++ ":" ++ atom(N),
            case get_attrval(app, E) of
                "" ->
                    S;
                A ->
                    "//" ++ atom(A) ++ "/" ++ S
            end
    end.

t_utype([E]) ->
    t_utype_elem(E).

t_utype_elem(E = #xmlElement{content = Es}) ->
    case get_attrval(name, E) of
        "" ->
            t_type(Es);
        Name ->
            T = t_type(Es),
            case T of
                [Name] ->
                    T;
                T ->
                    [Name] ++ ["::"] ++ T
            end
    end.

t_type([E = #xmlElement{name = typevar}]) ->
    t_var(E);
t_type([E = #xmlElement{name = atom}]) ->
    t_atom(E);
t_type([E = #xmlElement{name = integer}]) ->
    t_integer(E);
t_type([E = #xmlElement{name = range}]) ->
    t_range(E);
t_type([E = #xmlElement{name = binary}]) ->
    t_binary(E);
t_type([E = #xmlElement{name = float}]) ->
    t_float(E);
t_type([#xmlElement{name = nil}]) ->
    t_nil();
t_type([#xmlElement{name = paren,content = Es}]) ->
    t_paren(Es);
t_type([#xmlElement{name = list,content = Es}]) ->
    t_list(Es);
t_type([#xmlElement{name = nonempty_list,content = Es}]) ->
    t_nonempty_list(Es);
t_type([#xmlElement{name = tuple,content = Es}]) ->
    t_tuple(Es);
t_type([#xmlElement{name = 'fun',content = Es}]) ->
    ["fun("] ++ t_fun(Es) ++ [")"];
t_type([E = #xmlElement{name = record,content = Es}]) ->
    t_record(E, Es);
t_type([E = #xmlElement{name = abstype,content = Es}]) ->
    t_abstype(E, Es);
t_type([#xmlElement{name = union,content = Es}]) ->
    t_union(Es).

t_var(E) ->
    [get_attrval(name, E)].

t_atom(E) ->
    [get_attrval(value, E)].

t_integer(E) ->
    [get_attrval(value, E)].

t_range(E) ->
    [get_attrval(value, E)].

t_binary(E) ->
    [get_attrval(value, E)].

t_float(E) ->
    [get_attrval(value, E)].

t_nil() ->
    ["[]"].

t_paren(Es) ->
    ["("] ++ t_utype(get_elem(type, Es)) ++ [")"].

t_list(Es) ->
    ["["] ++ t_utype(get_elem(type, Es)) ++ ["]"].

t_nonempty_list(Es) ->
    ["["] ++ t_utype(get_elem(type, Es)) ++ [", ...]"].

t_tuple(Es) ->
    ["{"] ++ seq(fun t_utype_elem/1, Es, ["}"]).

t_fun(Es) ->
    ["("]
    ++
    seq(fun t_utype_elem/1,
        get_content(argtypes, Es),
        [") -> "] ++ t_utype(get_elem(type, Es))).

t_record(E, Es) ->
    Name = ["#"] ++ t_type(get_elem(atom, Es)),
    case get_elem(field, Es) of
        [] ->
            see(E, [Name,"{}"]);
        Fs ->
            see(E, Name) ++ ["{"] ++ seq(fun t_field/1, Fs, ["}"])
    end.

t_field(#xmlElement{content = Es}) ->
    t_type(get_elem(atom, Es)) ++ [" = "] ++ t_utype(get_elem(type, Es)).

t_abstype(E, Es) ->
    Name = t_name(get_elem(erlangName, Es)),
    case get_elem(type, Es) of
        [] ->
            see(E, [Name,"()"]);
        Ts ->
            see(E, [Name])
            ++
            ["("] ++ seq(fun t_utype_elem/1, Ts, [")"])
    end.

t_abstype(Es) ->
    [t_name(get_elem(erlangName, Es)),"("]
    ++
    seq(fun t_utype_elem/1, get_elem(type, Es), [")"]).

t_union(Es) ->
    seq(fun t_utype_elem/1, Es, " | ", []).

seq(F, Es) ->
    seq(F, Es, []).

seq(F, Es, Tail) ->
    seq(F, Es, ", ", Tail).

seq(F, [E], _Sep, Tail) ->
    F(E) ++ Tail;
seq(F, [E|Es], Sep, Tail) ->
    F(E) ++ [Sep] ++ seq(F, Es, Sep, Tail);
seq(_F, [], _Sep, Tail) ->
    Tail.

get_elem(Name, [#xmlElement{name = Name} = E|Es]) ->
    [E|get_elem(Name, Es)];
get_elem(Name, [_|Es]) ->
    get_elem(Name, Es);
get_elem(_, []) ->
    [].

get_attr(Name, [#xmlAttribute{name = Name} = A|As]) ->
    [A|get_attr(Name, As)];
get_attr(Name, [_|As]) ->
    get_attr(Name, As);
get_attr(_, []) ->
    [].

get_attrval(Name, #xmlElement{attributes = As}) ->
    case get_attr(Name, As) of
        [#xmlAttribute{value = V}] ->
            V;
        [] ->
            ""
    end.

get_content(Name, Es) ->
    case get_elem(Name, Es) of
        [#xmlElement{content = Es1}] ->
            Es1;
        [] ->
            []
    end.

get_text(Name, Es) ->
    case get_content(Name, Es) of
        [#xmlText{value = Text}] ->
            Text;
        [] ->
            ""
    end.

local_label(R) ->
    "#" ++ R.

xhtml(Title, CSS, Body) ->
    xhtml(Title, CSS, Body, "latin1").

xhtml(Title, CSS, Body, Encoding) ->
    EncString =
        case Encoding of
            "latin1" ->
                "ISO-8859-1";
            _ ->
                "UTF-8"
        end,
    [{html,
      ["\n",
       {head,
        ["\n",
         {meta,
          [{'http-equiv',"Content-Type"},
           {content,"text/html; charset=" ++ EncString}],
          []},
         "\n",
         {title,Title},
         "\n"]
        ++
        CSS},
       "\n",
       {body,[{bgcolor,"white"}],Body},
       "\n"]},
     "\n"].

type(E) ->
    type(E, []).

type(E, Ds) ->
    Opts = [],
    xmerl:export_simple_content(t_utype_elem(E) ++ local_defs(Ds, Opts),
                                xmerl_html).

package(E = #xmlElement{name = package,content = Es}, Options) ->
    Opts = init_opts(E, Options),
    Name = get_text(packageName, Es),
    Title = ["Package ",Name],
    Desc = get_content(description, Es),
    FullDesc = get_content(fullDescription, Desc),
    Body =
        ["\n",{h1,[Title]},"\n"]
        ++
        copyright(Es)
        ++
        deprecated(Es, "package")
        ++
        version(Es)
        ++
        since(Es)
        ++
        authors(Es)
        ++
        references(Es) ++ sees(Es) ++ todos(Es) ++ FullDesc,
    XML = xhtml(Title, stylesheet(Opts), Body),
    xmerl:export_simple(XML, xmerl_html, []).

overview(E = #xmlElement{name = overview,content = Es}, Options) ->
    Opts = init_opts(E, Options),
    Title = [get_text(title, Es)],
    Desc = get_content(description, Es),
    FullDesc = get_content(fullDescription, Desc),
    Body =
        navigation("top")
        ++
        ["\n",{h1,[Title]},"\n"]
        ++
        copyright(Es)
        ++
        version(Es)
        ++
        since(Es)
        ++
        authors(Es)
        ++
        references(Es)
        ++
        sees(Es)
        ++
        todos(Es)
        ++
        FullDesc ++ ["\n",hr] ++ navigation("bottom") ++ timestamp(),
    Encoding = get_attrval(encoding, E),
    XML = xhtml(Title, stylesheet(Opts), Body, Encoding),
    xmerl:export_simple(XML, xmerl_html, []).

ot_utype([E]) ->
    ot_utype_elem(E).

ot_utype_elem(E = #xmlElement{content = Es}) ->
    case get_attrval(name, E) of
        "" ->
            ot_type(Es);
        N ->
            Name = {var,0,list_to_atom(N)},
            T = ot_type(Es),
            case T of
                Name ->
                    T;
                T ->
                    {ann_type,0,[Name,T]}
            end
    end.

ot_type([E = #xmlElement{name = typevar}]) ->
    ot_var(E);
ot_type([E = #xmlElement{name = atom}]) ->
    ot_atom(E);
ot_type([E = #xmlElement{name = integer}]) ->
    ot_integer(E);
ot_type([E = #xmlElement{name = range}]) ->
    ot_range(E);
ot_type([E = #xmlElement{name = binary}]) ->
    ot_binary(E);
ot_type([E = #xmlElement{name = float}]) ->
    ot_float(E);
ot_type([#xmlElement{name = nil}]) ->
    ot_nil();
ot_type([#xmlElement{name = paren,content = Es}]) ->
    ot_paren(Es);
ot_type([#xmlElement{name = list,content = Es}]) ->
    ot_list(Es);
ot_type([#xmlElement{name = nonempty_list,content = Es}]) ->
    ot_nonempty_list(Es);
ot_type([#xmlElement{name = tuple,content = Es}]) ->
    ot_tuple(Es);
ot_type([#xmlElement{name = 'fun',content = Es}]) ->
    ot_fun(Es);
ot_type([#xmlElement{name = record,content = Es}]) ->
    ot_record(Es);
ot_type([#xmlElement{name = abstype,content = Es}]) ->
    ot_abstype(Es);
ot_type([#xmlElement{name = union,content = Es}]) ->
    ot_union(Es).

ot_var(E) ->
    {var,0,list_to_atom(get_attrval(name, E))}.

ot_atom(E) ->
    {ok,[Atom],_} = erl_scan:string(get_attrval(value, E), 0),
    Atom.

ot_integer(E) ->
    {integer,0,list_to_integer(get_attrval(value, E))}.

ot_range(E) ->
    [I1,I2] = string:tokens(get_attrval(value, E), "."),
    {type,
     0,
     range,
     [{integer,0,list_to_integer(I1)},{integer,0,list_to_integer(I2)}]}.

ot_binary(E) ->
    {Base,Unit} =
        case string:tokens(get_attrval(value, E), ",:*><") of
            [] ->
                {0,0};
            ["_",B] ->
                {list_to_integer(B),0};
            ["_","_",U] ->
                {0,list_to_integer(U)};
            ["_",B,_,"_",U] ->
                {list_to_integer(B),list_to_integer(U)}
        end,
    {type,0,binary,[{integer,0,Base},{integer,0,Unit}]}.

ot_float(E) ->
    {float,0,list_to_float(get_attrval(value, E))}.

ot_nil() ->
    {nil,0}.

ot_paren(Es) ->
    {paren_type,0,[ot_utype(get_elem(type, Es))]}.

ot_list(Es) ->
    {type,0,list,[ot_utype(get_elem(type, Es))]}.

ot_nonempty_list(Es) ->
    {type,0,nonempty_list,[ot_utype(get_elem(type, Es))]}.

ot_tuple(Es) ->
    {type,
     0,
     tuple,
     [ 
      ot_utype_elem(E) ||
          E <- Es
     ]}.

ot_fun(Es) ->
    Range = ot_utype(get_elem(type, Es)),
    Args =
        [ 
         ot_utype_elem(A) ||
             A <- get_content(argtypes, Es)
        ],
    {type,0,'fun',[{type,0,product,Args},Range]}.

ot_record(Es) ->
    {type,
     0,
     record,
     [ot_type(get_elem(atom, Es))|
      [ 
       ot_field(F) ||
           F <- get_elem(field, Es)
      ]]}.

ot_field(#xmlElement{content = Es}) ->
    {type,
     0,
     field_type,
     [ot_type(get_elem(atom, Es)),ot_utype(get_elem(type, Es))]}.

ot_abstype(Es) ->
    ot_name(get_elem(erlangName, Es),
            [ 
             ot_utype_elem(Elem) ||
                 Elem <- get_elem(type, Es)
            ]).

ot_union(Es) ->
    {type,
     0,
     union,
     [ 
      ot_utype_elem(E) ||
          E <- Es
     ]}.

ot_name(Es, T) ->
    case ot_name(Es) of
        [Mod,":",Atom] ->
            {remote_type,
             0,
             [{atom,0,list_to_atom(Mod)},{atom,0,list_to_atom(Atom)},T]};
        "tuple" when T =:= [] ->
            {type,0,tuple,any};
        Atom ->
            {type,0,list_to_atom(Atom),T}
    end.

ot_name([E]) ->
    Atom = get_attrval(name, E),
    case get_attrval(module, E) of
        "" ->
            Atom;
        M ->
            case get_attrval(app, E) of
                "" ->
                    [M,":",Atom];
                A ->
                    ["//" ++ A ++ "/" ++ M,":",Atom]
            end
    end.



